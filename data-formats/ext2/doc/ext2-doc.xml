<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!ENTITY tdg "DocBook: The Definitive Guide">

]>
<book id="Ext2.Internals" lang="en">
 <bookinfo>
  <title>The Second Extended File System</title>
  <subtitle>Internal Layout</subtitle>

  <authorgroup>
   <author>
    <firstname>Dave</firstname>
    <surname>Poirier</surname>
    <affiliation>
     <address>
      <email>ekscrypto@gmail.com</email>
     </address>
    </affiliation>
   </author>

  </authorgroup>

  <copyright>
   <year>2001-2019</year>
   <holder>Dave Poirier</holder>
  </copyright>

  <legalnotice>
   <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1
	or any later version published by the Free Software Foundation;
	with no Invariant Sections, with no Front-Cover Texts, and with no
	Back-Cover Texts. A copy of the license can be acquired electronically
	from http://www.fsf.org/licenses/fdl.html or by writing to 
	59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
   </para>
  </legalnotice>
 </bookinfo>

 
<toc></toc>

 <preface>
  <title>About this book</title>
  <para>
	The latest version of this document may be downloaded from
	https://www.nongnu.org/ext2-doc/
  </para>
  <para>
	This book is intended as an  introduction  and  guide  to  the  Second
	Extended File System, also known as Ext2.  The reader  should  have  a
	good understanding of the purpose of a file  system  as  well  as  the
	associated vocabulary (file, directory, partition, etc).
  </para>
  <para>
	Implementing file system drivers is already a daunting task, unfortunately
	except for tidbits of information here and there most of the documentation
	for the Second Extended Filesystem is in source files.
  </para>
  <para>
	Hopefully this document will fix this problem, may it be of help to as
	many of you as possible.
  </para>
  <para>
	<emphasis>Unless otherwise stated, all values  are  stored  in  little
	endian byte order.</emphasis>
  </para>
 </preface>

 <chapter id="history">
  <title>Historical Background</title>
  <para>
	Written by Remy Card, Theodore Ts'o and Stephen Tweedie as a major rewrite
	of the Extended Filesystem, it was first released to the public on January
	1993 as part of the Linux kernel.  One of its greatest achievement is the
	ability to extend the file system functionalities while maintaining the
	internal structures.  This allowed an easier development of the Third
	Extended Filesystem (ext3) and the Fourth Extended Filesystem (ext4).
  </para>
  <para>
	There are implementations available in most operating system including but
	not limited to NetBSD, FreeBSD, the GNU HURD, Microsoft Windows, IBM OS/2
	and RISC OS.
  </para>
  <para>
	Although newer file systems have been designed, such as Ext3 and Ext4, the
	Second Extended Filesystem is still prefered on flash drives as it requires
	fewer write operations (since it has no journal).  The structures of Ext3
	and Ext4 are based on Ext2 and add some additional options such as journaling,
	journal checksums, extents, online defragmentation, delayed allocations and
	larger directories to name but a few.
  </para>
 </chapter>

 <chapter id="Definitions">
  <title>Definitions</title>
  <para>
	The Second Extended Filesystem uses blocks as the basic unit of storage,
	inodes as the mean of keeping track of files and system objects, block groups
	to logically split the disk into more manageable sections, directories to
	provide a hierarchical organization of files, block and inode bitmaps to keep
	track of allocated blocks and inodes, and superblocks to define
	the parameters of the file system and its overall state.
  </para>
  <para>
	Ext2 shares many properties with traditional Unix filesystems.  It has space
	in the specification for Access Control Lists (ACLs), fragments, undeletion
	and compression.  There is also a versioning mechanism to allow new
	features (such as journalling) to be added in a maximally compatible
	manner; such as in Ext3 and Ext4.
  </para>
  <sect1 id="def-blocks">
   <title>Blocks</title>
   <para>
	A partition, disk, file or block device formated with a Second Extended
	Filesystem is divided into small groups of sectors called <quote>blocks</quote>.  These blocks are then grouped into larger units called block groups.
   </para>
   <para>
	The size of the blocks are usually determined when formatting the disk
	and will have an impact on performance, maximum file size, and maximum
	file system size.  Block sizes commonly implemented include 1KiB,
	2KiB, 4KiB and 8KiB although provisions in the superblock allow for
	block sizes as big as 1024 * (2^31)-1 (see
	<link linkend="s-log-block-size">s_log_block_size</link>).
   </para>
   <para>
	Depending on the implementation, some architectures may impose limits on
	which block sizes are supported.  For example, a Linux 2.6
	implementation on DEC Alpha uses blocks of 8KiB but the same
	implementation on a Intel 386 processor will support a maximum block
	size of 4KiB.
   </para>
   <table id="block-size-impact" frame="topbot" colsep="0" rowsep="0" pgwide="1">
    <title>Impact of Block Sizes</title>
    <tgroup cols='5' align='left'>
     <thead>
      <row>
       <entry>Upper Limits</entry>
       <entry>1KiB</entry>
       <entry>2KiB</entry>
       <entry>4KiB</entry>
       <entry>8KiB</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>file system blocks</entry>
       <entry>2,147,483,647</entry>
       <entry>2,147,483,647</entry>
       <entry>2,147,483,647</entry>
       <entry>2,147,483,647</entry>
      </row>
      <row>
       <entry>blocks per block group</entry>
       <entry>8,192</entry>
       <entry>16,384</entry>
       <entry>32,768</entry>
       <entry>65,536</entry>
      </row>
      <row>
       <entry>inodes per block group</entry>
       <entry>8,192</entry>
       <entry>16,384</entry>
       <entry>32,768</entry>
       <entry>65,536</entry>
      </row>
      <row>
       <entry>bytes per block group</entry>
       <entry>8,388,608 (8MiB)</entry>
       <entry>33,554,432 (32MiB)</entry>
       <entry>134,217,728 (128MiB)</entry>
       <entry>536,870,912 (512MiB)</entry>
      </row>
      <row>
       <entry>file system size (real)</entry>
       <entry>4,398,046,509,056 (4TiB)</entry>
       <entry>8,796,093,018,112 (8TiB)</entry>
       <entry>17,592,186,036,224 (16TiB)</entry>
       <entry>35,184,372,080,640 (32TiB)</entry>
      </row>
      <row>
       <entry>file system size (Linux)</entry>
       <entry>2,199,023,254,528 (2TiB)
        <footnote>
         <para>
	This limit comes from the maximum size of a block device in
	Linux 2.4; it is unclear whether a Linux 2.6 kernel using a 1KiB block
	size could properly format and mount a Ext2 partition larger than 2TiB.
         </para>
        </footnote>
       </entry>
       <entry>8,796,093,018,112 (8TiB)</entry>
       <entry>17,592,186,036,224 (16TiB)</entry>
       <entry>35,184,372,080,640 (32TiB)</entry>
      </row>
      <row>
       <entry>blocks per file</entry>
       <entry>16,843,020</entry>
       <entry>134,217,728</entry>
       <entry>1,074,791,436</entry>
       <entry>8,594,130,956</entry>
      </row>
      <row>
       <entry>file size (real)</entry>
       <entry>17,247,252,480 (16GiB)</entry>
       <entry>274,877,906,944 (256GiB)</entry>
       <entry>2,199,023,255,552 (2TiB)</entry>
       <entry>2,199,023,255,552 (2TiB)</entry>
      </row>
      <row>
       <entry>file size (Linux 2.6.28)</entry>
       <entry>17,247,252,480 (16GiB)</entry>
       <entry>274,877,906,944 (256GiB)</entry>
       <entry>2,199,023,255,552 (2TiB)</entry>
       <entry>2,199,023,255,552 (2TiB)</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
	Note: the 2TiB file size is limited by the i_blocks value in the inode which indicates the number of 512-bytes sector rather than the actual number of ext2 blocks allocated.
   </para>
  </sect1>

  <sect1 id="def-block-groups">
   <title>Block Groups</title>
   <epigraph><para>
	This definition comes from the Linux Kernel Documentation.
   </para></epigraph>
   <para>
	Blocks are clustered into block groups in order to reduce fragmentation
	and minimise the amount of head seeking when reading a large amount
	of consecutive data.  Information about each block group is kept in a
	descriptor table stored in the block(s) immediately after the superblock.
	Two blocks near the start of each group are reserved for the block usage
	bitmap and the inode usage bitmap which show which blocks and inodes
	are in use.  Since each bitmap is limited to a single block, this means
	that the maximum size of a block group is 8 times the size of a block.
   </para>
   <para>
	The block(s) following the bitmaps in each block group are designated
	as the inode table for that block group and the remainder are the data
	blocks.  The block allocation algorithm attempts to allocate data blocks
	in the same block group as the inode which contains them.
   </para>
  </sect1>

  <sect1 id="def-directories">
   <title>Directories</title>
   <epigraph><para>
	This definition comes from the Linux Kernel Documentation with some minor
	alterations.
   </para></epigraph>
   <para>
	A directory is a filesystem object and has an inode just like a file.
	It is a specially formatted file containing records which associate
	each name with an inode number.  Later revisions of the filesystem also
	encode the type of the object (file, directory, symlink, device, fifo,
	socket) to avoid the need to check the inode itself for this information
   </para>
   <para>
	The inode allocation code should try to assign inodes which are in the same
	block group as the directory in which they are first created.
   </para>
   <para>
	The original Ext2 revision used singly-linked list to store
	the filenames in the directory; newer revisions are able to use hashes
	and binary trees.
   </para>
   <para>
	Also note that as directory grows additional blocks are assigned to
	store the additional file records. When filenames are removed, some
	implementations do not free these additional blocks.
   </para>
  </sect1>

  <sect1 id="def-inodes">
   <title>Inodes</title>
   <epigraph><para>
	This definition comes from the Linux Kernel Documentation with some minor
	alterations.
   </para></epigraph>
   <para>
	The inode (index node) is a fundamental concept in the ext2 filesystem.
	Each object in the filesystem is represented by an inode.  The inode
	structure contains pointers to the filesystem blocks which contain the
	data held in the object and all of the metadata about an object except
	its name.  The metadata about an object includes the permissions, owner,
	group, flags, size, number of blocks used, access time, change time,
	modification time, deletion time, number of links, fragments, version
	(for NFS) and extended attributes (EAs) and/or Access Control Lists (ACLs).
   </para>
   <para>
	There are some reserved fields which are currently unused in the inode
	structure and several which are overloaded.  One field is reserved for the
	directory ACL if the inode is a directory and alternately for the top 32
	bits of the file size if the inode is a regular file (allowing file sizes
	larger than 2GB).  The translator field is unused under Linux, but is used
	by the HURD to reference the inode of a program which will be used to
	interpret this object.  Most of the remaining reserved fields have been
	used up for both Linux and the HURD for larger owner and group fields,
	The HURD also has a larger mode field so it uses another of the remaining
	fields to store the extra bits.
   </para>
   <para>
	There are pointers to the first 12 blocks which contain the file's data
	in the inode.  There is a pointer to an indirect block (which contains
	pointers to the next set of blocks), a pointer to a doubly-indirect
	block (which contains pointers to indirect blocks) and a pointer to a
	trebly-indirect block (which contains pointers to doubly-indirect blocks).
   </para>
   <para>
	Some filesystem specific behaviour flags are also stored and allow for
	specific filesystem behaviour on a per-file basis. There are flags for
	secure deletion, undeletable, compression, synchronous updates,
	immutability, append-only, dumpable, no-atime, indexed directories, and
	data-journaling.
   </para>
   <para>
	Many of the filesystem specific behaviour flags, like journaling, have been
	implemented in newer filesystems like Ext3 and Ext4, while some other
	are still under development.
   </para>
   <para>
	All the inodes are stored in inode tables, with one inode table per block group.
   </para>
  </sect1>

  <sect1 id="def-superblock">
   <title>Superblocks</title>
   <epigraph><para>
	This definition comes from the Linux Kernel Documentation with some minor
	alterations.
   </para></epigraph>
   <para>
	The superblock contains all the information about the configuration of
	the filesystem.  The information in the superblock contains fields
	such as the total number of inodes and blocks in the filesystem and how
	many are free, how many inodes and blocks are in each block group, when
	the filesystem was mounted (and if it was cleanly unmounted), when it
	was modified, what version of the filesystem it is and which OS created
	it.
   </para>
   <para>
	The primary copy of the superblock is stored at an offset of 1024 bytes
	from the start of the device, and it is essential to mounting the
	filesystem.  Since it is so important, backup copies of the superblock
	are stored in block groups throughout the filesystem.
   </para>
   <para>
	The first version of ext2 (revision 0) stores a copy at the start of
	every block group, along with backups of the group descriptor block(s).
	Because this can consume a considerable amount of space for large
	filesystems, later revisions can optionally reduce the number of backup
	copies by only putting backups in specific groups (this is the sparse
	superblock feature). The groups chosen are 0, 1 and powers of 3, 5 and 7.
   </para>
   <para>
	Revision 1 and higher of the filesystem also store extra fields, such as
	a volume name, a unique identification number, the inode size, and space
	for optional filesystem features to store configuration info.
   </para>
   <para>
	All fields in the superblock (as in all other ext2 structures) are stored
	on the disc in little endian format, so a filesystem is portable between
	machines without having to know what machine it was created on.
   </para>
  </sect1>

  <sect1 id="def-symbolic-links">
   <title>Symbolic Links</title>
   <epigraph><para>
	This definition comes from Wikipedia.org with some minor
	alterations.
   </para></epigraph>
   <para>
	A symbolic link (also symlink or soft link) is a special type of file that
	contains a reference to another file or directory in the form of an
	absolute or relative path and that affects pathname resolution.
   </para>
   <para>
	Symbolic links operate transparently for most operations: programs which
	read or write to files named by a symbolic link will behave as if
	operating directly on the target file.  However, programs that need to
	handle symbolic links specially (e.g., backup utilities) may identify
	and manipulate them directly.
   </para>
   <para>
	A symbolic link merely contains a text string that is interpreted and
	followed by the operating system as a path to another file or directory.
	It is a file on its own and can exist independently of its target.  The
	symbolic links do not affect an inode link count.  If a symbolic link is
	deleted, its target remains unaffected.  If the target is moved, renamed
	or deleted, any symbolic link that used to point to it continues to exist
	but now points to a non-existing file.  Symbolic links pointing to
	non-existing files are sometimes called <quote>orphaned</quote> or 
	<quote>dangling</quote>.
   </para>
   <para>
	Symbolic links are also filesystem objects with inodes.  For all symlink
	shorter than 60 bytes long, the data is stored within the inode itself; it
	uses the fields which would normally be used to store the pointers to data
	blocks. This is a worthwhile optimisation as it we avoid allocating a full
	block for the symlink, and most symlinks are less than 60 characters long.
   </para>
   <para>
	Symbolic links can also point to files or directories of other partitions
	and file systems.
   </para>
  </sect1>
 </chapter>

 <chapter id="disk-organisation">
  <title>Disk Organization</title>
  <para>
	An Ext2 file systems starts with a <link linkend="superblock">superblock</link>
	located at byte offset 1024 from the start of the volume. This is block 1
	for a 1KiB block formatted volume or within block 0 for larger block sizes.  Note that the size of the superblock is constant regardless of the block size.
  </para>
  <para>
	On the next block(s) following the superblock, is the 
	Block Group Descriptor Table; which provides an overview of how the volume
	is split into block groups and where to find the inode bitmap, the block bitmap,
	and the inode table for each block group.
  </para>
  <para>
	In revision 0 of Ext2, each block group consists of a copy superblock, a copy of the
	block group descriptor table, a block bitmap, an inode bitmap, an inode table,
	and data blocks.
  </para>
  <para>
	With the introduction of revision 1 and the sparse superblock feature in Ext2,
	only specific block groups contain copies of the superblock and block group
	descriptor table.  All block groups still contain the block bitmap, inode
	bitmap, inode table, and data blocks.  The shadow copies of the superblock can
	be located in block groups 0, 1 and powers of 3, 5 and 7.
  </para>
  <para>
	The block bitmap and inode bitmap are limited to 1 block each per block group,
	so the total blocks per block group is therefore limited. (More information in
	the <link linkend="block-size-impact">Block Size Impact</link> table).
  </para>
  <para>
	Each data block may also be further divided into <quote>fragments</quote>. As of
	Linux 2.6.28, support for fragment was still not implemented in the kernel;
	it is therefore suggested to ensure the fragment size is equal to the
	block size so as to maintain compatibility.
  </para>
  <table id="disk-layout-sample-floppy" frame="topbot" colsep="0" rowsep="0" pgwide="1">
   <title>Sample Floppy Disk Layout, 1KiB blocks</title>
   <tgroup cols="3">
    <colspec colwidth="20*" colname="c1" />
    <colspec colwidth="20*" colname="c2" />
    <colspec colwidth="60*" colname="c3" />
    <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
    <thead>
     <row>
      <entry>Block Offset</entry>
      <entry>Length</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>byte 0</entry>
      <entry>512 bytes</entry>
      <entry>boot record (if present)</entry>
     </row>
     <row>
      <entry>byte 512</entry>
      <entry>512 bytes</entry>
      <entry>additional boot record data (if present)</entry>
     </row>
     <row>
      <entry spanname="hdr">-- block group 0, blocks 1 to 1439 --</entry>
     </row>
     <row>
      <entry>byte 1024</entry>
      <entry>1024 bytes</entry>
      <entry><link linkend="superblock">superblock</link></entry>
     </row>
     <row>
      <entry>block 2</entry>
      <entry>1 block</entry>
      <entry><link linkend="block-group-descriptor-table">block group descriptor table</link></entry>
     </row>
     <row>
      <entry>block 3</entry>
      <entry>1 block</entry>
      <entry><link linkend="block-bitmap">block bitmap</link></entry>
     </row>
     <row>
      <entry>block 4</entry>
      <entry>1 block</entry>
      <entry><link linkend="inode-bitmap">inode bitmap</link></entry>
     </row>
     <row>
      <entry>block 5</entry>
      <entry>23 blocks</entry>
      <entry><link linkend="inode-table">inode table</link></entry>
     </row>
     <row>
      <entry>block 28</entry>
      <entry>1412 blocks</entry>
      <entry>data blocks</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
	For the curious, block 0 always points to the first sector of the disk
	or partition and will always contain the boot record if one is present.
  </para><para>
	The superblock is always located at byte offset 1024 from the start of
	the disk or partition.  In a 1KiB block-size formatted file system, this is
	block 1, but it will always be block 0 (at 1024 bytes within block 0) in
	larger block size file systems.
  </para><para>
	And here's the organisation of a 20MB ext2 file system, using 1KiB blocks:
  </para>
  <table id="disk-layout-sample-20mb" frame="topbot" colsep="0" rowsep="0" pgwide="1">
   <title>Sample 20mb Partition Layout</title>
   <tgroup cols="3">
    <colspec colwidth="20*" colname="c1" />
    <colspec colwidth="20*" colname="c2" />
    <colspec colwidth="60*" colname="c3" />
    <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
    <thead>
     <row>
      <entry>Block Offset</entry>
      <entry>Length</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>byte 0</entry>
      <entry>512 bytes</entry>
      <entry>boot record (if present)</entry>
     </row>
     <row>
      <entry>byte 512</entry>
      <entry>512 bytes</entry>
      <entry>additional boot record data (if present)</entry>
     </row>
     <row>
      <entry spanname="hdr">-- block group 0, blocks 1 to 8192 --</entry>
     </row>
     <row>
      <entry>byte 1024</entry>
      <entry>1024 bytes</entry>
      <entry><link linkend="superblock">superblock</link></entry>
     </row>
     <row>
      <entry>block 2</entry>
      <entry>1 block</entry>
      <entry><link linkend="block-group-descriptor-table">block group descriptor table</link></entry>
     </row>
     <row>
      <entry>block 3</entry>
      <entry>1 block</entry>
      <entry><link linkend="block-bitmap">block bitmap</link></entry>
     </row>
     <row>
      <entry>block 4</entry>
      <entry>1 block</entry>
      <entry><link linkend="inode-bitmap">inode bitmap</link></entry>
     </row>
     <row>
      <entry>block 5</entry>
      <entry>214 blocks</entry>
      <entry><link linkend="inode-table">inode table</link></entry>
     </row>
     <row>
      <entry>block 219</entry>
      <entry>7974 blocks</entry>
      <entry>data blocks</entry>
     </row>
     <row>
      <entry spanname="hdr">-- block group 1, blocks 8193 to 16384 --</entry>
     </row>
     <row>
      <entry>block 8193</entry>
      <entry>1 block</entry>
      <entry><link linkend="superblock">superblock</link> backup</entry>
     </row>
     <row>
      <entry>block 8194</entry>
      <entry>1 block</entry>
      <entry><link linkend="block-group-descriptor-table">block group descriptor table</link> backup</entry>
     </row>
     <row>
      <entry>block 8195</entry>
      <entry>1 block</entry>
      <entry><link linkend="block-bitmap">block bitmap</link></entry>
     </row>
     <row>
      <entry>block 8196</entry>
      <entry>1 block</entry>
      <entry><link linkend="inode-bitmap">inode bitmap</link></entry>
     </row>
     <row>
      <entry>block 8197</entry>
      <entry>214 blocks</entry>
      <entry><link linkend="inode-table">inode table</link></entry>
     </row>
     <row>
      <entry>block 8408</entry>
      <entry>7974 blocks</entry>
      <entry>data blocks</entry>
     </row>
     <row>
      <entry spanname="hdr">-- block group 2, blocks 16385 to 24576 --</entry>
     </row>
     <row>
      <entry>block 16385</entry>
      <entry>1 block</entry>
      <entry><link linkend="block-bitmap">block bitmap</link></entry>
     </row>
     <row>
      <entry>block 16386</entry>
      <entry>1 block</entry>
      <entry><link linkend="inode-bitmap">inode bitmap</link></entry>
     </row>
     <row>
      <entry>block 16387</entry>
      <entry>214 blocks</entry>
      <entry><link linkend="inode-table">inode table</link></entry>
     </row>
     <row>
      <entry>block 16601</entry>
      <entry>3879 blocks</entry>
      <entry>data blocks</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
	The layout on disk is very predictable as long as you know a few basic
	information; block size, blocks per  group,  inodes  per  group.  This
	information  is  all  located  in,  or  can  be  computed  from,   the
	<structname>superblock</structname> structure.
  </para>
  <para>
	Nevertheless, unless the image was crafted with controlled parameters,
	the position of the various structures on disk (except the superblock)
	should never be assumed.  Always load the superblock first.
  </para>
  <para>
	Notice how block 0 is not part of the block group 0 in 1KiB block
	size file systems.  The reason for this is block group 0 always starts
	with the block containing the superblock.  Hence, on 1KiB block systems,
	block group 0 starts at block 1, but on larger block sizes it starts on
	block 0.  For more information, see the
	<link linkend="s-first-data-block">s_first_data_block</link> superblock
	entry.
  </para>

  <sect1 id="superblock"><title>Superblock</title>
   <para>
	The <link linkend="def-superblock">superblock</link> is always located at
	byte offset 1024 from the beginning of the file, block device or
	partition formatted with Ext2 and later variants (Ext3, Ext4).
   </para>
   <para>
	Its structure is mostly constant from Ext2 to Ext3 and Ext4 with only
	some minor changes.
   </para>
   <table id="superblock-structure" frame="topbot" colsep="0" rowsep="0" pgwide="1">
    <title>Superblock Structure</title>
    <tgroup cols="3">
     <colspec colwidth="20*" colname="c1" />
     <colspec colwidth="20*" colname="c2" />
     <colspec colwidth="60*" colname="c3" />
     <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
     <thead>
      <row>
       <entry>Offset (bytes)</entry>
       <entry>Size (bytes)</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>0</entry>
       <entry>4</entry>
       <entry><link linkend="s-inodes-count">s_inodes_count</link></entry>
      </row>
      <row>
       <entry>4</entry>
       <entry>4</entry>
       <entry><link linkend="s-blocks-count">s_blocks_count</link></entry>
      </row>
      <row>
       <entry>8</entry>
       <entry>4</entry>
       <entry><link linkend="s-r-blocks-count">s_r_blocks_count</link></entry>
      </row>
      <row>
       <entry>12</entry>
       <entry>4</entry>
       <entry><link linkend="s-free-blocks-count">s_free_blocks_count</link></entry>
      </row>
      <row>
       <entry>16</entry>
       <entry>4</entry>
       <entry><link linkend="s-free-inodes-count">s_free_inodes_count</link></entry>
      </row>
      <row>
       <entry>20</entry>
       <entry>4</entry>
       <entry><link linkend="s-first-data-block">s_first_data_block</link></entry>
      </row>
      <row>
       <entry>24</entry>
       <entry>4</entry>
       <entry><link linkend="s-log-block-size">s_log_block_size</link></entry>
      </row>
      <row>
       <entry>28</entry>
       <entry>4</entry>
       <entry><link linkend="s-log-frag-size">s_log_frag_size</link></entry>
      </row>
      <row>
       <entry>32</entry>
       <entry>4</entry>
       <entry><link linkend="s-blocks-per-group">s_blocks_per_group</link></entry>
      </row>
      <row>
       <entry>36</entry>
       <entry>4</entry>
       <entry><link linkend="s-frags-per-group">s_frags_per_group</link></entry>
      </row>
      <row>
       <entry>40</entry>
       <entry>4</entry>
       <entry><link linkend="s-inodes-per-group">s_inodes_per_group</link></entry>
      </row>
      <row>
       <entry>44</entry>
       <entry>4</entry>
       <entry><link linkend="s-mtime">s_mtime</link></entry>
      </row>
      <row>
       <entry>48</entry>
       <entry>4</entry>
       <entry><link linkend="s-wtime">s_wtime</link></entry>
      </row>
      <row>
       <entry>52</entry>
       <entry>2</entry>
       <entry><link linkend="s-mnt-count">s_mnt_count</link></entry>
      </row>
      <row>
       <entry>54</entry>
       <entry>2</entry>
       <entry><link linkend="s-max-mnt-count">s_max_mnt_count</link></entry>
      </row>
      <row>
       <entry>56</entry>
       <entry>2</entry>
       <entry><link linkend="s-magic">s_magic</link></entry>
      </row>
      <row>
       <entry>58</entry>
       <entry>2</entry>
       <entry><link linkend="s-state">s_state</link></entry>
      </row>
      <row>
       <entry>60</entry>
       <entry>2</entry>
       <entry><link linkend="s-errors">s_errors</link></entry>
      </row>
      <row>
       <entry>62</entry>
       <entry>2</entry>
       <entry><link linkend="s-minor-rev-level">s_minor_rev_level</link></entry>
      </row>
      <row>
       <entry>64</entry>
       <entry>4</entry>
       <entry><link linkend="s-lastcheck">s_lastcheck</link></entry>
      </row>
      <row>
       <entry>68</entry>
       <entry>4</entry>
       <entry><link linkend="s-checkinterval">s_checkinterval</link></entry>
      </row>
      <row>
       <entry>72</entry>
       <entry>4</entry>
       <entry><link linkend="s-creator-os">s_creator_os</link></entry>
      </row>
      <row>
       <entry>76</entry>
       <entry>4</entry>
       <entry><link linkend="s-rev-level">s_rev_level</link></entry>
      </row>
      <row>
       <entry>80</entry>
       <entry>2</entry>
       <entry><link linkend="s-def-resuid">s_def_resuid</link></entry>
      </row>
      <row>
       <entry>82</entry>
       <entry>2</entry>
       <entry><link linkend="s-def-resgid">s_def_resgid</link></entry>
      </row>
      <row rowsep="1">
       <entry spanname="hdr">-- EXT2_DYNAMIC_REV Specific --</entry>
      </row>
      <row>
       <entry>84</entry>
       <entry>4</entry>
       <entry><link linkend="s-first-ino">s_first_ino</link></entry>
      </row>
      <row>
       <entry>88</entry>
       <entry>2</entry>
       <entry><link linkend="s-inode-size">s_inode_size</link></entry>
      </row>
      <row>
       <entry>90</entry>
       <entry>2</entry>
       <entry><link linkend="s-block-group-nr">s_block_group_nr</link></entry>
      </row>
      <row>
       <entry>92</entry>
       <entry>4</entry>
       <entry><link linkend="s-feature-compat">s_feature_compat</link></entry>
      </row>
      <row>
       <entry>96</entry>
       <entry>4</entry>
       <entry><link linkend="s-feature-incompat">s_feature_incompat</link></entry>
      </row>
      <row>
       <entry>100</entry>
       <entry>4</entry>
       <entry><link linkend="s-feature-ro-compat">s_feature_ro_compat</link></entry>
      </row>
      <row>
       <entry>104</entry>
       <entry>16</entry>
       <entry><link linkend="s-uuid">s_uuid</link></entry>
      </row>
      <row>
       <entry>120</entry>
       <entry>16</entry>
       <entry><link linkend="s-volume-name">s_volume_name</link></entry>
      </row>
      <row>
       <entry>136</entry>
       <entry>64</entry>
       <entry><link linkend="s-last-mounted">s_last_mounted</link></entry>
      </row>
      <row>
       <entry>200</entry>
       <entry>4</entry>
       <entry><link linkend="s-algo-bitmap">s_algo_bitmap</link></entry>
      </row>
      <row rowsep="1">
       <entry spanname="hdr">-- Performance Hints --</entry>
      </row>
      <row>
       <entry>204</entry>
       <entry>1</entry>
       <entry><link linkend="s-prealloc-blocks">s_prealloc_blocks</link></entry>
      </row>
      <row>
       <entry>205</entry>
       <entry>1</entry>
       <entry><link linkend="s-prealloc-dir-blocks">s_prealloc_dir_blocks</link></entry>
      </row>
      <row>
       <entry>206</entry>
       <entry>2</entry>
       <entry>(alignment)</entry>
      </row>
      <row rowsep="1">
       <entry spanname="hdr">-- Journaling Support --</entry>
      </row>
      <row>
       <entry>208</entry>
       <entry>16</entry>
       <entry><link linkend="s-journal-uuid">s_journal_uuid</link></entry>
      </row>
      <row>
       <entry>224</entry>
       <entry>4</entry>
       <entry><link linkend="s-journal-inum">s_journal_inum</link></entry>
      </row>
      <row>
       <entry>228</entry>
       <entry>4</entry>
       <entry><link linkend="s-journal-dev">s_journal_dev</link></entry>
      </row>
      <row>
       <entry>232</entry>
       <entry>4</entry>
       <entry><link linkend="s-last-orphan">s_last_orphan</link></entry>
      </row>
	<row rowsep="1">
	 <entry spanname="hdr">-- Directory Indexing Support --</entry>
	</row>
      <row>
       <entry>236</entry>
       <entry>4 x 4</entry>
       <entry><link linkend="s-hash-seed">s_hash_seed</link></entry>
      </row>
      <row>
       <entry>252</entry>
       <entry>1</entry>
       <entry><link linkend="s-def-hash-version">s_def_hash_version</link></entry>
      </row>
      <row>
       <entry>253</entry>
       <entry>3</entry>
       <entry>padding - reserved for future expansion</entry>
      </row>
      <row rowsep="1">
       <entry spanname="hdr">-- Other options --</entry>
      </row>
      <row>
       <entry>256</entry>
       <entry>4</entry>
       <entry><link linkend="s-default-mount-options">s_default_mount_options</link></entry>
      </row>
      <row>
       <entry>260</entry>
       <entry>4</entry>
       <entry><link linkend="s-first-meta-bg">s_first_meta_bg</link></entry>
      </row>
      <row>
       <entry>264</entry>
       <entry>760</entry>
       <entry>Unused - reserved for future revisions</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <sect2 id="s-inodes-count"><title>s_inodes_count</title>
    <para>
	32bit value indicating the total number of inodes, both used and free,
	in the file system.  This value must be lower or equal to
	(s_inodes_per_group * number of block groups).  It must be equal to the
	sum of the inodes defined in each block group.
    </para>
   </sect2>

   <sect2 id="s-blocks-count"><title>s_blocks_count</title>
    <para>
	32bit value indicating the total number of blocks in the system including
	all used, free and reserved. This value must be lower or equal to
	(s_blocks_per_group * number of block groups). It can be lower than
        the previous calculation if the last block group has a smaller number of
        blocks than s_blocks_per_group du to volume size.  It must be equal to
        the sum of the blocks defined in each block group.
    </para>
   </sect2>

   <sect2 id="s-r-blocks-count"><title>s_r_blocks_count</title>
    <para>
	32bit value indicating the total number of  blocks  reserved  for  the
	usage of the super user.  This is most useful if  for  some  reason  a
	user, maliciously or not, fill the file system to capacity; the  super
	user will have this specified amount of free blocks at his disposal so
	he can edit and save configuration files.
    </para>
   </sect2>

   <sect2 id="s-free-blocks-count"><title>s_free_blocks_count</title>
    <para>
	32bit value indicating the total number of free blocks, including  the
	number of reserved blocks (see
	<link linkend="s-r-blocks-count">s_r_blocks_count</link>).  This is a  sum
	of all free blocks of all the block groups.
    </para>
   </sect2>

   <sect2 id="s-free-inodes-count"><title>s_free_inodes_count</title>
    <para>
	32bit value indicating the total number of free inodes.  This is a sum
	of all free inodes of all the block groups.
    </para>
   </sect2>

   <sect2 id="s-first-data-block"><title>s_first_data_block</title>
    <para>
	32bit value identifying the first data block, in other word the id  of
	the block containing the <structname>superblock</structname> structure.
    </para>
    <para>
	Note that this value is always 0 for file systems with  a  block  size
	larger than 1KB, and always 1 for file systems with a  block  size  of
	1KB.  The <structname>superblock</structname> is <emphasis>always</emphasis> starting at
	the 1024th byte of the disk, which normally happens to  be  the  first
	byte of the 3rd sector.
    </para>
   </sect2>

   <sect2 id="s-log-block-size"><title>s_log_block_size</title>
    <para>
	The block size is computed using this 32bit value  as  the  number  of
	bits to shift left the value 1024.  This value may only be non-negative.
    </para>
    <programlisting>
block size = 1024 &lt;&lt; s_log_block_size;
    </programlisting>
    <para>
	Common block sizes include 1KiB, 2KiB, 4KiB and 8Kib. For information
	about the impact of selecting a block size, see
	<link linkend="block-size-impact">Impact of Block Sizes</link>.
    </para>
    <note>
     <para>
	In Linux, at least up to 2.6.28, the block size must be at least as
	large as the sector size of the block device, and cannot be larger than
	the supported memory page of the architecture.
     </para>
    </note>
   </sect2>

   <sect2 id="s-log-frag-size"><title>s_log_frag_size</title>
    <para>
	The fragment size is computed using this 32bit value as the number  of
	bits to shift left the value 1024.  Note that a negative  value  would
	shift the bit right rather than left.
    </para>
    <programlisting>
if( positive )
  fragmnet size = 1024 &lt;&lt; s_log_frag_size;
else
  framgnet size = 1024 &gt;&gt; -s_log_frag_size;
    </programlisting>
    <note>
     <para>
	As of Linux 2.6.28 no support exists for an Ext2
	partition with fragment size smaller than the block size, as this feature
	seems to not be available.
     </para>
    </note>
   </sect2>

   <sect2 id="s-blocks-per-group"><title>s_blocks_per_group</title>
    <para>
	32bit value indicating the total number  of  blocks  per  group.  This
	value in combination with
	<link linkend="s-first-data-block">s_first_data_block</link> can  be  used
	to determine the block groups boundaries.  Due to volume size boundaries,
        the last block group might have a smaller number of blocks than what is
        specified in this field.
    </para>
   </sect2>

   <sect2 id="s-frags-per-group"><title>s_frags_per_group</title>
    <para>
	32bit value indicating the total number of fragments per group.  It is
	also used to determine the size of the <structname>block bitmap</structname>  of
	each block group.
    </para>
   </sect2>

   <sect2 id="s-inodes-per-group"><title>s_inodes_per_group</title>
    <para>
	32bit value indicating the total number of inodes per group.  This  is
	also used to determine the size of the <structname>inode bitmap</structname>  of
	each block group.  Note that you cannot have more than
	(block size in bytes * 8) inodes per group as the inode bitmap
	must fit within a single block. This value must be a perfect multiple
	of the number of inodes that can fit in a block
	((1024&lt;&lt;s_log_block_size)/s_inode_size).
    </para>
   </sect2>

   <sect2 id="s-mtime"><title>s_mtime</title>
    <para>
	Unix time, as defined by POSIX, of the last time the file  system  was
	mounted.
    </para>
   </sect2>

   <sect2 id="s-wtime"><title>s_wtime</title>
    <para>
	Unix time, as defined by POSIX, of the last write access to  the  file
	system.
    </para>
   </sect2>

   <sect2 id="s-mnt-count"><title>s_mnt_count</title>
    <para>
	16bit value indicating how many  time  the  file  system  was  mounted
	since the last time it was fully verified.
    </para>
   </sect2>

   <sect2 id="s-max-mnt-count"><title>s_max_mnt_count</title>
    <para>
	16bit value indicating the maximum  number  of  times  that  the  file
	system may be mounted before a full check is performed.
    </para>
   </sect2>

   <sect2 id="s-magic"><title>s_magic</title>
    <para>
	16bit value  identifying  the  file  system  as  Ext2.  The  value  is
	currently fixed to <constant>EXT2_SUPER_MAGIC</constant> of value 0xEF53.
    </para>
   </sect2>

   <sect2 id="s-state"><title>s_state</title>
    <para>
	16bit value indicating the file system state.  When the file system is
	mounted, this state is set  to  <constant>EXT2_ERROR_FS</constant>.  After the
	file system was cleanly unmounted, this value is set to <constant>EXT2_VALID_FS</constant>.
    </para>
    <para>
	When mounting the file system, if a valid of <constant>EXT2_ERROR_FS</constant> is
	encountered it means the file system was not cleanly unmounted and most
	likely contain errors that will need to be fixed.  Typically under Linux
	this means running fsck.
    </para>
    <table id="s-state-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Defined s_state Values</title>
     <tgroup align="left" cols="3">
      <colspec colwidth="40*" />
      <colspec colwidth="20*" />
      <colspec colwidth="40*" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row><entry>EXT2_VALID_FS</entry><entry>1</entry><entry>Unmounted cleanly</entry></row>
       <row><entry>EXT2_ERROR_FS</entry><entry>2</entry><entry>Errors detected</entry></row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="s-errors"><title>s_errors</title>
    <para>
	16bit value indicating what the file system driver should do  when  an
	error is detected.  The following values have been defined:
    </para>
    <table frame="topbot" colsep="0" rowsep="0" pgwide="1" id="ext2-errors">
     <title>Defined s_errors Values</title>
     <tgroup align="left" cols="3">
      <colspec colwidth="40*" />
      <colspec colwidth="20*" />
      <colspec colwidth="40*" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>EXT2_ERRORS_CONTINUE</entry>
        <entry>1</entry>
        <entry>continue as if nothing happened</entry>
       </row>
       <row>
        <entry>EXT2_ERRORS_RO</entry>
        <entry>2</entry>
        <entry>remount read-only</entry>
       </row>
       <row>
        <entry>EXT2_ERRORS_PANIC</entry>
        <entry>3</entry>
        <entry>cause a kernel panic</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="s-minor-rev-level"><title>s_minor_rev_level</title>
    <para>
	16bit value identifying the minor revision level within its
	<link linkend="s-rev-level">revision level</link>.
    </para>
   </sect2>

   <sect2 id="s-lastcheck"><title>s_lastcheck</title>
    <para>
	Unix time, as defined by POSIX, of the last file system check.
    </para>
   </sect2>

   <sect2 id="s-checkinterval"><title>s_checkinterval</title>
    <para>
	Maximum Unix time interval, as defined by POSIX, allowed between file
	system checks.
    </para>
   </sect2>

   <sect2 id="s-creator-os"><title>s_creator_os</title>
    <para>
	32bit identifier of the os that created the file system.  Defined
	values are:
    </para>
    <table id="s-creator-os-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Defined s_creator_os Values</title>
     <tgroup cols="3" align="left">
      <colspec colwidth="40*" />
      <colspec colwidth="20*" />
      <colspec colwidth="40*" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>EXT2_OS_LINUX</entry>
        <entry>0</entry>
        <entry>Linux</entry>
       </row>
       <row>
        <entry>EXT2_OS_HURD</entry>
        <entry>1</entry>
        <entry>GNU HURD</entry>
       </row>
       <row>
        <entry>EXT2_OS_MASIX</entry>
        <entry>2</entry>
        <entry>MASIX</entry>
       </row>
       <row>
        <entry>EXT2_OS_FREEBSD</entry>
        <entry>3</entry>
        <entry>FreeBSD</entry>
       </row>
       <row>
        <entry>EXT2_OS_LITES</entry>
        <entry>4</entry>
        <entry>Lites</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="s-rev-level"><title>s_rev_level</title>
    <para>
	32bit revision level value.
    </para>
    <table id="s-rev-level-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Defined s_rev_level Values</title>
     <tgroup cols="3" align="left">
      <colspec colwidth="40*" />
      <colspec colwidth="20*" />
      <colspec colwidth="40*" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>EXT2_GOOD_OLD_REV</entry>
        <entry>0</entry>
        <entry>Revision 0</entry>
       </row>
       <row>
        <entry>EXT2_DYNAMIC_REV</entry>
        <entry>1</entry>
        <entry>Revision 1 with variable inode sizes, extended attributes, etc.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="s-def-resuid"><title>s_def_resuid</title>
    <para>
	16bit value used as the default user id for reserved blocks.  
    </para>
    <note><para>
	In Linux this defaults to <constant>EXT2_DEF_RESUID</constant> of 0.
    </para></note>
   </sect2>

   <sect2 id="s-def-resgid"><title>s_def_resgid</title>
    <para>
	16bit value used as the default group id for reserved blocks.
    </para>
    <note><para>
	In Linux this defaults to <constant>EXT2_DEF_RESGID</constant> of 0.
    </para></note>
   </sect2>

   <sect2 id="s-first-ino"><title>s_first_ino</title>
    <para>
	32bit value used as index to the  first  inode  useable  for  standard
	files. In revision 0, the first	non-reserved inode is fixed to
	11 (<constant>EXT2_GOOD_OLD_FIRST_INO</constant>). In revision 1 and later
	this value may be set to any value.
    </para>
   </sect2>

   <sect2 id="s-inode-size"><title>s_inode_size</title>
    <para>
	16bit value indicating the size of the inode structure. In revision 0, this
	value is always 128 (<constant>EXT2_GOOD_OLD_INODE_SIZE</constant>). In revision 1
	and later, this value must be a perfect power of 2 and must be smaller or
	equal to the block size (1&lt;&lt;s_log_block_size).
    </para>
   </sect2>

   <sect2 id="s-block-group-nr"><title>s_block_group_nr</title>
    <para>
	16bit value used to indicate the block group number hosting this
	superblock structure.  This can be used to rebuild the file system
	from any superblock backup.
    </para>
   </sect2>

   <sect2 id="s-feature-compat"><title>s_feature_compat</title>
    <para>
	32bit bitmask of compatible features.  The file system implementation
	is free to support them or not without risk of damaging the meta-data.
    </para>
    <table id="s-feature-compat-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Defined s_feature_compat Values</title>
     <tgroup cols="3" align="left">
      <colspec colwidth="40*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="40*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry spanname="hdr">EXT2_FEATURE_COMPAT_DIR_PREALLOC</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0001</entry>
        <entry>Block pre-allocation for new directories</entry>
       </row>
       <row>
        <entry spanname="hdr">EXT2_FEATURE_COMPAT_IMAGIC_INODES</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0002</entry>
        <entry></entry>
       </row>
       <row>
        <entry spanname="hdr">EXT3_FEATURE_COMPAT_HAS_JOURNAL</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0004</entry>
        <entry>An Ext3 journal exists</entry>
       </row>
       <row>
        <entry spanname="hdr">EXT2_FEATURE_COMPAT_EXT_ATTR</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0008</entry>
        <entry>Extended inode attributes are present</entry>
       </row>
       <row>
        <entry spanname="hdr">EXT2_FEATURE_COMPAT_RESIZE_INO</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0010</entry>
        <entry>Non-standard inode size used</entry>
       </row>
       <row>
        <entry spanname="hdr">EXT2_FEATURE_COMPAT_DIR_INDEX</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0020</entry>
        <entry>Directory indexing (HTree)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="s-feature-incompat"><title>s_feature_incompat</title>
    <para>
	32bit bitmask of incompatible features.  The file system
	implementation should refuse to mount the file system if any of
	the indicated feature is unsupported.
    </para>
    <para>
	An implementation not supporting these features would be unable to
	properly use the file system.  For example, if compression is being
	used and an executable file would be unusable after being read from
	the disk if the system does not know how to uncompress it.
    </para>
    <table id="s-feature-incompat-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Defined s_feature_incompat Values</title>
     <tgroup cols="3" align="left">
      <colspec colwidth="40*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="40*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry spanname="hdr">EXT2_FEATURE_INCOMPAT_COMPRESSION</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0001</entry>
        <entry>Disk/File compression is used</entry>
       </row>
       <row>
        <entry spanname="hdr">EXT2_FEATURE_INCOMPAT_FILETYPE</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0002</entry>
        <entry></entry>
       </row>
       <row>
        <entry spanname="hdr">EXT3_FEATURE_INCOMPAT_RECOVER</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0004</entry>
        <entry></entry>
       </row>
       <row>
        <entry spanname="hdr">EXT3_FEATURE_INCOMPAT_JOURNAL_DEV</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0008</entry>
        <entry></entry>
       </row>
       <row>
        <entry spanname="hdr">EXT2_FEATURE_INCOMPAT_META_BG</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0010</entry>
        <entry></entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="s-feature-ro-compat"><title>s_feature_ro_compat</title>
    <para>
	32bit bitmask of <quote>read-only</quote> features.  The file system
	implementation should mount as read-only if any of the indicated
	feature is unsupported.
    </para>
    <table id="s-feature-ro-compat-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Defined s_feature_ro_compat Values</title>
     <tgroup cols="3" align="left">
      <colspec colwidth="40*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="40*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
	     <row>
        <entry spanname="hdr">EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0001</entry>
        <entry>Sparse Superblock</entry>
       </row>
       <row>
        <entry spanname="hdr">EXT2_FEATURE_RO_COMPAT_LARGE_FILE</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0002</entry>
        <entry>Large file support, 64-bit file size</entry>
       </row>
       <row>
        <entry spanname="hdr">EXT2_FEATURE_RO_COMPAT_BTREE_DIR</entry>
       </row>
       <row>
        <entry></entry>
        <entry>0x0004</entry>
        <entry>Binary tree sorted directory files</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="s-uuid"><title>s_uuid</title>
    <para>
	128bit value used as the volume id.  This should, as much as possible,
	be unique for each file system formatted.
    </para>
   </sect2>

   <sect2 id="s-volume-name"><title>s_volume_name</title>
    <para>
	16 bytes volume name, mostly unusued.  A valid volume name would consist
	of only ISO-Latin-1 characters and be 0 terminated.
    </para>
   </sect2>

   <sect2 id="s-last-mounted"><title>s_last_mounted</title>
    <para>
	64 bytes directory path where the file system was last mounted.  While
	not normally used, it could serve for auto-finding the mountpoint when
	not indicated on the command line. Again the path should be zero
	terminated for compatibility reasons.  Valid path is constructed from
	ISO-Latin-1 characters.
    </para>
   </sect2>

   <sect2 id="s-algo-bitmap"><title>s_algo_bitmap</title>
    <para>
	32bit value used by compression algorithms to determine the compression
	method(s) used.
    </para>
    <note><para>
	Compression is supported in Linux 2.4 and 2.6 via the e2compr patch. For
	more information, visit http://e2compr.sourceforge.net/
    </para></note>
    <table id="s-algo-bitmap-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Defined s_algo_bitmap Values</title>
     <tgroup cols="3" align="left">
      <colspec colwidth="40*" />
      <colspec colwidth="20*" />
      <colspec colwidth="40*" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Bit Number</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>EXT2_LZV1_ALG</entry>
        <entry>0</entry>
        <entry>Binary value of 0x00000001</entry>
       </row>
       <row>
        <entry>EXT2_LZRW3A_ALG</entry>
        <entry>1</entry>
        <entry>Binary value of 0x00000002</entry>
       </row>
       <row>
        <entry>EXT2_GZIP_ALG</entry>
        <entry>2</entry>
        <entry>Binary value of 0x00000004</entry>
       </row>
       <row>
        <entry>EXT2_BZIP2_ALG</entry>
        <entry>3</entry>
        <entry>Binary value of 0x00000008</entry>
       </row>
       <row>
        <entry>EXT2_LZO_ALG</entry>
        <entry>4</entry>
        <entry>Binary value of 0x00000010</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="s-prealloc-blocks"><title>s_prealloc_blocks</title>
    <para>
	8-bit value representing the number of blocks the implementation should
	attempt to pre-allocate when creating a new regular file.  
    </para>
    <para>
	Linux 2.6.28 will only perform pre-allocation using Ext4 although no
	problem is expected if any version of Linux encounters a file with more
	blocks present than required.
    </para>
   </sect2>

   <sect2 id="s-prealloc-dir-blocks"><title>s_prealloc_dir_blocks</title>
    <para>
	8-bit value representing the number of blocks the implementation should
	attempt to pre-allocate when creating a new directory.
    </para>
    <para>
	Linux 2.6.28 will only perform pre-allocation using Ext4 and only if
	the <constant>EXT4_FEATURE_COMPAT_DIR_PREALLOC</constant> flag is present. Since
	Linux does not de-allocate blocks from directories after they were
	allocated, it should be safe to perform pre-allocation and maintain
	compatibility with Linux.
    </para>
   </sect2>

   <sect2 id="s-journal-uuid"><title>s_journal_uuid</title>
    <para>
	16-byte value containing the uuid of the journal superblock.  See Ext3 
	Journaling for more information.
    </para>
   </sect2>

   <sect2 id="s-journal-inum"><title>s_journal_inum</title>
    <para>
	32-bit inode number of the journal file.  See Ext3 Journaling for more 
	information.
    </para>
   </sect2>

   <sect2 id="s-journal-dev"><title>s_journal_dev</title>
    <para>
	32-bit device number of the journal file.  See Ext3 Journaling for more 
	information.
    </para>
   </sect2>

   <sect2 id="s-last-orphan"><title>s_last_orphan</title>
    <para>
	32-bit inode number, pointing to the first inode in the list of inodes
	to delete.  See Ext3 Journaling for more information.
    </para>
   </sect2>

   <sect2 id="s-hash-seed"><title>s_hash_seed</title>
    <para>
	An array of 4 32bit values containing the seeds used for the hash 
	algorithm for directory indexing.
    </para>
   </sect2>

   <sect2 id="s-def-hash-version"><title>s_def_hash_version</title>
    <para>
	An 8bit value containing the default hash version used for directory indexing.
    </para>
   </sect2>

   <sect2 id="s-default-mount-options"><title>s_default_mount_options</title>
    <para>
	A 32bit value containing the default mount options for this file system. TODO: Add more information here!
    </para>
   </sect2>

   <sect2 id="s-first-meta-bg"><title>s_first_meta_bg</title>
    <para>
	A 32bit value indicating the block group ID of the first meta block group.  TODO: Research if this is an Ext3-only extension.
    </para>
   </sect2>
  </sect1>

  <sect1 id="block-group-descriptor-table"><title>Block Group Descriptor Table</title>
   <para>
	The block group descriptor table is an array of 
	<link linkend="block-group-descriptor-structure">block group descriptor</link>, 
	used to define parameters of all the 
  <link linkend="def-block-groups">block groups</link>. It provides the location
	of the inode bitmap	and inode table, block bitmap, number of free blocks and
	inodes, and some other useful information.
   </para><para>
	The block group descriptor table starts on the first block following the
	superblock.  This would be the third block on a 1KiB block file system, or the
	second block for 2KiB and larger block file systems. Shadow copies of the
	block	group descriptor table are also stored with every copy of the 
	superblock.
   </para><para>
	Depending on how many block groups are defined, this table can require
	multiple blocks of storage.  Always refer to the superblock in case of
	doubt.
   </para><para>
	The layout of a block group descriptor is as follows:
   </para>
   <table id="block-group-descriptor-structure" frame="topbot" colsep="0" rowsep="0" pgwide="1">
    <title>Block Group Descriptor Structure</title>
    <tgroup cols="3">
     <colspec colwidth="20*" colname="c1" />
     <colspec colwidth="20*" colname="c2" />
     <colspec colwidth="60*" colname="c3" />
     <thead>
      <row>
       <entry>Offset (bytes)</entry>
       <entry>Size (bytes)</entry>
       <entry>Description</entry>
      </row>
     </thead><tbody>
      <row>
       <entry>0</entry>
       <entry>4</entry>
       <entry><link linkend="bg-block-bitmap">bg_block_bitmap</link></entry>
      </row>
      <row>
       <entry>4</entry>
       <entry>4</entry>
       <entry><link linkend="bg-inode-bitmap">bg_inode_bitmap</link></entry>
      </row>
      <row>
       <entry>8</entry>
       <entry>4</entry>
       <entry><link linkend="bg-inode-table">bg_inode_table</link></entry>
      </row>
      <row>
       <entry>12</entry>
       <entry>2</entry>
       <entry><link linkend="bg-free-blocks-count">bg_free_blocks_count</link></entry>
      </row>
      <row>
       <entry>14</entry>
       <entry>2</entry>
       <entry><link linkend="bg-free-inodes-count">bg_free_inodes_count</link></entry>
      </row>
      <row>
       <entry>16</entry>
       <entry>2</entry>
       <entry><link linkend="bg-used-dirs-count">bg_used_dirs_count</link></entry>
      </row>
      <row>
       <entry>18</entry>
       <entry>2</entry>
       <entry><link linkend="bg-pad">bg_pad</link></entry>
      </row>
      <row>
       <entry>20</entry>
       <entry>12</entry>
       <entry><link linkend="bg-reserved">bg_reserved</link></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
	For each block group in the file system, such a <structname>group_desc</structname> is
	created.  Each represent a single block group within the
	file system and the information within any one of them is pertinent
	only to the group it is describing.  Every block group descriptor table
	contains all the information about all the block groups.
   </para>
   <para>
	NOTE: All indicated <quote>block id</quote> are absolute.
   </para>

   <sect2 id="bg-block-bitmap"><title>bg_block_bitmap</title>
    <para>
	32bit block id of the first block of the
	<quote><link linkend="block-bitmap">block bitmap</link></quote>
	for the group represented.
    </para>
    <para>
	The actual block bitmap is located within its own allocated blocks 
	starting at the block ID specified by this value.
    </para>
   </sect2>

   <sect2 id="bg-inode-bitmap"><title>bg_inode_bitmap</title>
    <para>
	32bit block id of the first block of the
	<quote><link linkend="inode-bitmap">inode bitmap</link></quote>
	for the group represented.
    </para>
   </sect2>

   <sect2 id="bg-inode-table"><title>bg_inode_table</title>
    <para>
	32bit block id of the first block of the
	<quote><link linkend="inode-table">inode table</link></quote>
	for the group represented.
    </para>
   </sect2>

   <sect2 id="bg-free-blocks-count"><title>bg_free_blocks_count</title>
    <para>
	16bit value indicating the total number of free blocks for
	the represented group.
    </para>
   </sect2>

   <sect2 id="bg-free-inodes-count"><title>bg_free_inodes_count</title>
    <para>
	16bit value indicating the total number of free inodes for
	the represented group.
    </para>
   </sect2>

   <sect2 id="bg-used-dirs-count"><title>bg_used_dirs_count</title>
    <para>
	16bit value indicating the number of inodes allocated to
	directories for the represented group.
    </para>
   </sect2>

   <sect2 id="bg-pad"><title>bg_pad</title>
    <para>
	16bit value used for padding the structure on a 32bit boundary.
    </para>
   </sect2>

   <sect2 id="bg-reserved"><title>bg_reserved</title>
    <para>
	12 bytes of reserved space for future revisions.
    </para>
   </sect2>
  </sect1>

  <sect1 id="block-bitmap"><title>Block Bitmap</title>
   <para>
	On small file systems, the <quote>Block Bitmap</quote> is normally located
	at the first block, or second block if a superblock backup is present,
	of each block group. Its official location can be determined by reading the
	<quote><link linkend="bg-block-bitmap">bg_block_bitmap</link></quote>
	in its associated <link linkend="block-group-descriptor-table">group descriptor</link>.
   </para>
   <para>
	Each bit represent the current state of a block within that block group,
	where 1 means <quote>used</quote> and 0 <quote>free/available</quote>. The
	first block of this block group is represented by bit 0 of byte 0,
	the second by bit 1 of byte 0.  The 8th block is represented by bit 7
	(most significant bit) of byte 0 while the 9th block is represented by
	bit 0 (least significant bit) of byte 1.
   </para>
  </sect1>

  <sect1 id="inode-bitmap"><title>Inode Bitmap</title>
   <para>
	The <quote>Inode Bitmap</quote> works in a similar way as the
	<quote><link linkend="block-bitmap">Block Bitmap</link></quote>,
	difference being in each bit representing an inode in the
	<quote><link linkend="inode-table">Inode Table</link></quote> rather
	than a block.  Since inode numbers start from 1 rather than 0, the
        first bit in the first block group's inode bitmap represent inode
        number 1.
   </para>
   <para>
	There is one inode bitmap per group and its location may be
	determined by reading the
	<quote><link linkend="bg-inode-bitmap">bg_inode_bitmap</link></quote>
	in its associated <link linkend="block-group-descriptor-table">group descriptor</link>.
   </para>
   <para>
   	When the inode table is created, all the reserved inodes are marked
	as used.  In revision 0 this is the first 11 inodes.
   </para>
  </sect1>

  <sect1 id="inode-table"><title>Inode Table</title>
   <para>
	The inode table is used to keep track of every directory,
	regular file, symbolic link, or special file; their
	location, size, type and access rights are all stored in inodes. There
	is no filename stored in the inode itself, names are contained in
	<link linkend="directory">directory</link> files only.
   </para>
   <para>
	There is one inode table per block group and it can be located by reading the
	<link linkend="bg-inode-table">bg_inode_table</link>
	in its associated <link linkend="block-group-descriptor-table">group descriptor</link>.
	There are <link linkend="s-inodes-per-group">s_inodes_per_group</link>
	inodes per table.
   </para>

   <para>
	Each inode contain the information about a single physical file on the
	system.  A file can be a directory, a socket, a buffer, character or
	block device, symbolic link or a regular file.  So an inode can be
	seen as a block of information related to an entity, describing its
	location on disk, its size and its owner.  An inode looks like this:
   </para>
   <table id="inode-structure" frame="topbot" colsep="0" rowsep="0" pgwide="1">
    <title>Inode Structure</title>
    <tgroup cols="3">
     <colspec colwidth="20*" colname="c1" />
     <colspec colwidth="20*" colname="c2" />
     <colspec colwidth="60*" colname="c3" />
     <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
     <thead>
      <row>
       <entry>Offset (bytes)</entry>
       <entry>Size (bytes)</entry>
       <entry>Description</entry>
      </row>
     </thead><tbody>
      <row>
       <entry>0</entry>
       <entry>2</entry>
       <entry><link linkend="i-mode">i_mode</link></entry>
      </row>
      <row>
       <entry>2</entry>
       <entry>2</entry>
       <entry><link linkend="i-uid">i_uid</link></entry>
      </row>
      <row>
       <entry>4</entry>
       <entry>4</entry>
       <entry><link linkend="i-size">i_size</link></entry>
      </row>
      <row>
       <entry>8</entry>
       <entry>4</entry>
       <entry><link linkend="i-atime">i_atime</link></entry>
      </row>
      <row>
       <entry>12</entry>
       <entry>4</entry>
       <entry><link linkend="i-ctime">i_ctime</link></entry>
      </row>
      <row>
       <entry>16</entry>
       <entry>4</entry>
       <entry><link linkend="i-mtime">i_mtime</link></entry>
      </row>
      <row>
       <entry>20</entry>
       <entry>4</entry>
       <entry><link linkend="i-dtime">i_dtime</link></entry>
      </row>
      <row>
       <entry>24</entry>
       <entry>2</entry>
       <entry><link linkend="i-gid">i_gid</link></entry>
      </row>
      <row>
       <entry>26</entry>
       <entry>2</entry>
       <entry><link linkend="i-links-count">i_links_count</link></entry>
      </row>
      <row>
       <entry>28</entry>
       <entry>4</entry>
       <entry><link linkend="i-blocks">i_blocks</link></entry>
      </row>
      <row>
       <entry>32</entry>
       <entry>4</entry>
       <entry><link linkend="i-flags">i_flags</link></entry>
      </row>
      <row>
       <entry>36</entry>
       <entry>4</entry>
       <entry><link linkend="i-osd1">i_osd1</link></entry>
      </row>
      <row>
       <entry>40</entry>
       <entry>15 x 4</entry>
       <entry><link linkend="i-block">i_block</link></entry>
      </row>
      <row>
       <entry>100</entry>
       <entry>4</entry>
       <entry><link linkend="i-generation">i_generation</link></entry>
      </row>
      <row>
       <entry>104</entry>
       <entry>4</entry>
       <entry><link linkend="i-file-acl">i_file_acl</link></entry>
      </row>
      <row>
       <entry>108</entry>
       <entry>4</entry>
       <entry><link linkend="i-dir-acl">i_dir_acl</link></entry>
      </row>
      <row>
       <entry>112</entry>
       <entry>4</entry>
       <entry><link linkend="i-faddr">i_faddr</link></entry>
      </row>
      <row>
       <entry>116</entry>
       <entry>12</entry>
       <entry><link linkend="i-osd2">i_osd2</link></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
	The first few entries of the inode tables are reserved.  In revision
	0 there are 11 entries reserved while in revision 1
	(EXT2_DYNAMIC_REV) and later the number of reserved inodes entries is
	specified	in the <link linkend="s-first-ino">s_first_ino</link> of the 
	superblock structure.  Here's a listing of the known reserved inode 
	entries:
   </para>
   <table id="reserved-inodes-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
    <title>Defined Reserved Inodes</title>
     <tgroup cols="3" align="left">
      <colspec colwidth="40*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="40*" colname="c3" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
      <row>
       <entry>EXT2_BAD_INO</entry>
       <entry>1</entry>
       <entry>bad blocks inode</entry>
      </row>
      <row>
       <entry>EXT2_ROOT_INO</entry>
       <entry>2</entry>
       <entry>root directory inode</entry>
      </row>
      <row>
       <entry>EXT2_ACL_IDX_INO</entry>
       <entry>3</entry>
       <entry>ACL index inode (deprecated?)</entry>
      </row>
      <row>
       <entry>EXT2_ACL_DATA_INO</entry>
       <entry>4</entry>
       <entry>ACL data inode (deprecated?)</entry>
      </row>
      <row>
       <entry>EXT2_BOOT_LOADER_INO</entry>
       <entry>5</entry>
       <entry>boot loader inode</entry>
      </row>
      <row>
       <entry>EXT2_UNDEL_DIR_INO</entry>
       <entry>6</entry>
       <entry>undelete directory inode</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <sect2 id="i-mode"><title>i_mode</title>
    <para>
	16bit value used to indicate the format of the described file and the
	access rights.  Here are the possible values, which can be combined
	in various ways:
    </para>
    <table pgwide="1" frame="topbot" colsep="0" rowsep="0" >
     <title>Defined i_mode Values</title>
     <tgroup cols="3" align="left">
      <colspec colwidth="40*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="40*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
      <thead>
       <row>
        <entry>Constant</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry spanname="hdr" rowsep="1">-- file format --</entry>
       </row>
       <row>
        <entry>EXT2_S_IFSOCK</entry>
        <entry>0xC000</entry>
        <entry>socket</entry>
       </row>
       <row>
        <entry>EXT2_S_IFLNK</entry>
        <entry>0xA000</entry>
        <entry>symbolic link</entry>
       </row>
       <row>
        <entry>EXT2_S_IFREG</entry>
        <entry>0x8000</entry>
        <entry>regular file</entry>
       </row>
       <row>
        <entry>EXT2_S_IFBLK</entry>
        <entry>0x6000</entry>
        <entry>block device</entry>
       </row>
       <row>
        <entry>EXT2_S_IFDIR</entry>
        <entry>0x4000</entry>
        <entry>directory</entry>
       </row>
       <row>
        <entry>EXT2_S_IFCHR</entry>
        <entry>0x2000</entry>
        <entry>character device</entry>
       </row>
       <row>
        <entry>EXT2_S_IFIFO</entry>
        <entry>0x1000</entry>
        <entry>fifo</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">-- process execution user/group override --</entry>
       </row>
       <row>
        <entry>EXT2_S_ISUID</entry>
        <entry>0x0800</entry>
        <entry>Set process User ID</entry>
       </row>
       <row>
        <entry>EXT2_S_ISGID</entry>
        <entry>0x0400</entry>
        <entry>Set process Group ID</entry>
       </row>
       <row>
        <entry>EXT2_S_ISVTX</entry>
        <entry>0x0200</entry>
        <entry>sticky bit</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">-- access rights --</entry>
       </row>
       <row>
        <entry>EXT2_S_IRUSR</entry>
        <entry>0x0100</entry>
        <entry>user read</entry>
       </row>
       <row>
        <entry>EXT2_S_IWUSR</entry>
        <entry>0x0080</entry>
        <entry>user write</entry>
       </row>
       <row>
        <entry>EXT2_S_IXUSR</entry>
        <entry>0x0040</entry>
        <entry>user execute</entry>
       </row>
       <row>
        <entry>EXT2_S_IRGRP</entry>
        <entry>0x0020</entry>
        <entry>group read</entry>
       </row>
       <row>
        <entry>EXT2_S_IWGRP</entry>
        <entry>0x0010</entry>
        <entry>group write</entry>
       </row>
       <row>
        <entry>EXT2_S_IXGRP</entry>
        <entry>0x0008</entry>
        <entry>group execute</entry>
       </row>
       <row>
        <entry>EXT2_S_IROTH</entry>
        <entry>0x0004</entry>
        <entry>others read</entry>
       </row>
       <row>
        <entry>EXT2_S_IWOTH</entry>
        <entry>0x0002</entry>
        <entry>others write</entry>
       </row>
       <row>
        <entry>EXT2_S_IXOTH</entry>
        <entry>0x0001</entry>
        <entry>others execute</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="i-uid"><title>i_uid</title>
    <para>
	16bit user id associated with the file.
    </para>
   </sect2>

   <sect2 id="i-size"><title>i_size</title>
    <para>
	In revision 0, (signed) 32bit value indicating the size of the file in 
	bytes.  In revision 1 and later revisions, and only for regular files, this 
	represents the lower 32-bit of the file size; the upper 32-bit is located
	in the i_dir_acl.
    </para>
   </sect2>

   <sect2 id="i-atime"><title>i_atime</title>
    <para>
	32bit value representing the number of seconds since january 1st 1970
	of the last time this inode was accessed.
    </para>
   </sect2>

   <sect2 id="i-ctime"><title>i_ctime</title>
    <para>
	32bit value representing the number of seconds since january 1st 1970, of
	when the inode was created.
    </para>
   </sect2>

   <sect2 id="i-mtime"><title>i_mtime</title>
    <para>
	32bit value representing the number of seconds since january 1st 1970,
	of the last time this inode was modified.
    </para>
   </sect2>

   <sect2 id="i-dtime"><title>i_dtime</title>
    <para>
	32bit value representing the number of seconds since january 1st 1970, of
	when the inode was deleted.
    </para>
   </sect2>

   <sect2 id="i-gid"><title>i_gid</title>
    <para>
	16bit value of the POSIX group having access to this file.
    </para>
   </sect2>

   <sect2 id="i-links-count"><title>i_links_count</title>
    <para>
	16bit value indicating how many times this particular inode is linked 
	(referred to). Most files will have a link count of 1.  Files with hard 
	links pointing to them will have an additional count for each hard link.
    </para>
    <para>
	Symbolic links do not affect the link count of an inode. When the link count
	reaches 0 the inode and all its associated blocks are freed.
    </para>
   </sect2>

   <sect2 id="i-blocks"><title>i_blocks</title>
    <para>
	32-bit value representing the total number of 512-bytes blocks reserved to contain the
	data of this inode, regardless if these blocks are used or not.  The block
	numbers of these reserved blocks are contained in the 
	<link linkend="i-block">i_block</link> array.
    </para>
    <para>
	Since this value represents 512-byte blocks and not file system blocks,
	this value should not be directly used as an index to the i_block array.
	Rather, the maximum index of the i_block array should be computed from
	i_blocks / ((1024&lt;&lt;s_log_block_size)/512), or once simplified, i_blocks/(2&lt;&lt;s_log_block_size).
    </para>
   </sect2>

   <sect2 id="i-flags"><title>i_flags</title>
    <para>
	32bit value indicating how the ext2 implementation should behave when
	accessing the data for this inode.
    </para>
    <table id="defined-i-flags-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Defined i_flags Values</title>
     <tgroup cols="3">
      <colspec colwidth="40*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="40*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><link linkend="ext2-secrm-fl">EXT2_SECRM_FL</link></entry>
        <entry>0x00000001</entry>
        <entry>secure deletion</entry>
       </row>
       <row>
        <entry><link linkend="ext2-unrm-fl">EXT2_UNRM_FL</link></entry>
        <entry>0x00000002</entry>
        <entry>record for undelete</entry>
       </row>
       <row>
        <entry><link linkend="ext2-compr-fl">EXT2_COMPR_FL</link></entry>
        <entry>0x00000004</entry>
        <entry>compressed file</entry>
       </row>
       <row>
        <entry><link linkend="ext2-sync-fl">EXT2_SYNC_FL</link></entry>
        <entry>0x00000008</entry>
        <entry>synchronous updates</entry>
       </row>
       <row>
        <entry><link linkend="ext2-immutable-fl">EXT2_IMMUTABLE_FL</link></entry>
        <entry>0x00000010</entry>
        <entry>immutable file</entry>
       </row>
       <row>
        <entry><link linkend="ext2-append-fl">EXT2_APPEND_FL</link></entry>
        <entry>0x00000020</entry>
        <entry>append only</entry>
       </row>
       <row>
        <entry><link linkend="ext2-nodump-fl">EXT2_NODUMP_FL</link></entry>
        <entry>0x00000040</entry>
        <entry>do not dump/delete file</entry>
       </row>
       <row>
        <entry><link linkend="ext2-noatime-fl">EXT2_NOATIME_FL</link></entry>
        <entry>0x00000080</entry>
        <entry>do not update .i_atime</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">-- Reserved for compression usage --</entry>
       </row>
       <row>
        <entry><link linkend="ext2-dirty-fl">EXT2_DIRTY_FL</link></entry>
        <entry>0x00000100</entry>
        <entry>Dirty (modified)</entry>
       </row>
       <row>
        <entry><link linkend="ext2-comprblk-fl">EXT2_COMPRBLK_FL</link></entry>
        <entry>0x00000200</entry>
        <entry>compressed blocks</entry>
       </row>
       <row>
        <entry><link linkend="ext2-nocompr-fl">EXT2_NOCOMPR_FL</link></entry>
        <entry>0x00000400</entry>
        <entry>access raw compressed data</entry>
       </row>
       <row>
        <entry><link linkend="ext2-ecompr-fl">EXT2_ECOMPR_FL</link></entry>
        <entry>0x00000800</entry>
        <entry>compression error</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">-- End of compression flags --</entry>
       </row>
       <row>
        <entry><link linkend="ext2-btree-fl">EXT2_BTREE_FL</link></entry>
        <entry>0x00001000</entry>
        <entry>b-tree format directory</entry>
       </row>
       <row>
        <entry><link linkend="ext2-index-fl">EXT2_INDEX_FL</link></entry>
        <entry>0x00001000</entry>
        <entry>hash indexed directory</entry>
       </row>
       <row>
        <entry><link linkend="ext2-imagic-fl">EXT2_IMAGIC_FL</link></entry>
        <entry>0x00002000</entry>
        <entry>AFS directory</entry>
       </row>
       <row>
        <entry><link linkend="ext3-journal-data-fl">EXT3_JOURNAL_DATA_FL</link></entry>
        <entry>0x00004000</entry>
        <entry>journal file data</entry>
       </row>
       <row>
        <entry><link linkend="ext2-reserved-fl">EXT2_RESERVED_FL</link></entry>
        <entry>0x80000000</entry>
        <entry>reserved for ext2 library</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="i-osd1"><title>i_osd1</title>
    <para>
        32bit OS dependant value.
    </para>
    <sect3 id="i-osd1-hurd"><title>Hurd</title>
     <para>
        32bit value labeled as <quote>translator</quote>.
     </para>
    </sect3>
    <sect3 id="i-osd1-linux"><title>Linux</title>
     <para>
        32bit value currently reserved.
     </para>
    </sect3>
    <sect3 id="i-osd1-masix"><title>Masix</title>
     <para>
        32bit value currently reserved.
     </para>
    </sect3>
   </sect2>

   <sect2 id="i-block"><title>i_block</title>
    <para>
	15 x 32bit block numbers pointing to the blocks containing the data for
	this inode. The first 12 blocks are direct blocks.  The 13th entry in this
	array is the block number of the first indirect block; which is a block
	containing an array of block ID containing the data.  Therefore, the 13th
	block of the file will be the first block ID contained in the indirect block.
	With a 1KiB block size, blocks 13 to 268 of the file data are contained
	in this indirect block.
     </para>
     <para>
	The 14th entry in this array is the block number of the first doubly-indirect
	block; which is a block containing an array of indirect block IDs, with each
	of those indirect blocks containing an array of blocks containing the data.  
	In a 1KiB block size, there would be 256 indirect blocks per doubly-indirect
	block, with 256 direct blocks per indirect block for a total of 65536 blocks 
	per doubly-indirect block.
     </para>
     <para>
	The 15th entry in this array is the block number of the triply-indirect 
	block; which is a	block containing an array of doubly-indrect block IDs,
	with each of those doubly-indrect block containing an array of indrect block,
	and each of those indirect block containing an array of direct block.  In a
	1KiB file system, this would be a total of 16777216 blocks per
	triply-indirect block.
     </para>
     <para>
	In the original implementation of Ext2, a value of 0 in this array effectively 
    terminated it with no further block defined. In sparse files, it is possible
    to have some blocks allocated and some others not yet allocated with the value 0
    being used to indicate which blocks are not yet allocated for this file.
    </para>
   </sect2>

   <sect2 id="i-generation"><title>i_generation</title>
    <para>
        32bit value used to indicate the file version (used by NFS).
    </para>
   </sect2>

   <sect2 id="i-file-acl"><title>i_file_acl</title>
    <para>
	32bit value indicating the block number containing the extended
	attributes. In revision 0 this value is always 0.
    </para>
    <note>
     <para>
      Patches and implementation status of ACL under Linux can generally be found at http://acl.bestbits.at/
     </para>
    </note>
   </sect2>

   <sect2 id="i-dir-acl"><title>i_dir_acl</title>
    <para>
	In revision 0 this 32bit value is always 0.  In revision 1, for regular
	files this 32bit value contains the high 32 bits of the 64bit file size.
    </para>
    <note>
     <para>
	Linux sets this value to 0 if the file is not a regular file (i.e. block
	devices, directories, etc).  In theory, this value could be set to point
	to a block containing extended attributes of the directory or special file.
     </para>
    </note>
   </sect2>

   <sect2 id="i-faddr"><title>i_faddr</title>
    <para>
	32bit value indicating the location of the file fragment.
    </para>
    <note><para>
	In Linux and GNU HURD, since fragments are unsupported this value is always 
	0.  In Ext4	this value is now marked as obsolete.
    </para>
    <para>
	In theory, this should contain the block number which hosts the
	actual fragment.  The fragment number and its size would be contained
	in the <link linkend="i-osd2">i_osd2</link> structure.
    </para></note>
   </sect2>

   <sect2 id="i-osd2"><title>Inode i_osd2 Structure</title>
    <para>
        96bit OS dependant structure.
    </para>

    <sect3 id="i-osd2-hurd"><title>Hurd</title>
     <table id="i-osd2-hurd-structure" frame="topbot" colsep="0" rowsep="0" pgwide="1">
      <title>Inode i_osd2 Structure: Hurd</title>
      <tgroup cols="3">
       <colspec colwidth="20*" colname="c1" />
       <colspec colwidth="20*" colname="c2" />
       <colspec colwidth="60*" colname="c3" />
       <thead>
        <row>
         <entry>Offset (bytes)</entry>
         <entry>Size (bytes)</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>0</entry>
         <entry>1</entry>
         <entry><link linkend="h-i-frag">h_i_frag</link></entry>
        </row>
        <row>
         <entry>1</entry>
         <entry>1</entry>
         <entry><link linkend="h-i-fsize">h_i_fsize</link></entry>
        </row>
        <row>
         <entry>2</entry>
         <entry>2</entry>
         <entry><link linkend="h-i-mode-high">h_i_mode_high</link></entry>
        </row>
        <row>
         <entry>4</entry>
         <entry>2</entry>
         <entry><link linkend="h-i-uid-high">h_i_uid_high</link></entry>
        </row>
        <row>
         <entry>6</entry>
         <entry>2</entry>
         <entry><link linkend="h-i-gid-high">h_i_gid_high</link></entry>
        </row>
        <row>
         <entry>8</entry>
         <entry>4</entry>
         <entry><link linkend="h-i-author">h_i_author</link></entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <sect4 id="h-i-frag"><title>h_i_frag</title>
      <para>
	8bit fragment number.  Always 0 GNU HURD since fragments are
	not supported. Obsolete with Ext4.
      </para>
     </sect4>
     <sect4 id="h-i-fsize"><title>h_i_fsize</title>
      <para>
	8bit fragment size.  Always 0 in GNU HURD since fragments are
	not supported.  Obsolete with Ext4.
      </para>
     </sect4>
     <sect4 id="h-i-mode-high"><title>h_i_mode_high</title>
      <para>
	High 16bit of the 32bit mode.
      </para>
     </sect4>
     <sect4 id="h-i-uid-high"><title>h_i_uid_high</title>
      <para>
	High 16bit of <link linkend="i-uid">user id</link>.
      </para>
     </sect4>
     <sect4 id="h-i-gid-high"><title>h_i_gid_high</title>
      <para>
	High 16bit of <link linkend="i-gid">group id</link>.
      </para>
     </sect4>
     <sect4 id="h-i-author"><title>h_i_author</title>
      <para>
	32bit user id of the assigned file author. If this value is set to -1, the 
	POSIX <link linkend="i-uid">user id</link> will be used.
      </para>
     </sect4>
    </sect3>

    <sect3 id="i-osd2-linux"><title>Linux</title>
     <table id="i-osd2-linux-structure" frame="topbot" colsep="0" rowsep="0" pgwide="1">
      <title>Inode i_osd2 Structure: Linux</title>
      <tgroup cols="3">
       <colspec colwidth="20*" colname="c1" />
       <colspec colwidth="20*" colname="c2" />
       <colspec colwidth="60*" colname="c3" />
       <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
       <thead>
        <row>
         <entry>Offset (bytes)</entry>
         <entry>Size (bytes)</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>0</entry>
         <entry>1</entry>
         <entry><link linkend="l-i-frag">l_i_frag</link></entry>
        </row>
        <row>
         <entry>1</entry>
         <entry>1</entry>
         <entry><link linkend="l-i-fsize">l_i_fsize</link></entry>
        </row>
        <row>
         <entry>2</entry>
         <entry>2</entry>
         <entry>reserved</entry>
        </row>
        <row>
         <entry>4</entry>
         <entry>2</entry>
         <entry><link linkend="l-i-uid-high">l_i_uid_high</link></entry>
        </row>
        <row>
         <entry>6</entry>
         <entry>2</entry>
         <entry><link linkend="l-i-gid-high">l_i_gid_high</link></entry>
        </row>
        <row>
         <entry>8</entry>
         <entry>4</entry>
         <entry>reserved</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <sect4 id="l-i-frag"><title>l_i_frag</title>
      <para>
	8bit fragment number.
      </para>
      <note><para>
	  Always 0 in Linux since fragments are not supported.
      </para></note>
      <important><para>
	A new implementation of Ext2 should completely disregard this field
	if the <link linkend="i-faddr">i_faddr</link> value is 0; in Ext4 this
	field is combined with <link linkend="l-i-fsize">l_i_fsize</link> to
	become the high 16bit of the 48bit blocks count for the inode data.
      </para></important>
     </sect4>
     <sect4 id="l-i-fsize"><title>l_i_fsize</title>
      <para>
	8bit fragment size.
      </para>
      <note><para>
	 Always 0 in Linux since fragments are not supported.
      </para></note>
      <important><para>
	A new implementation of Ext2 should completely disregard this field
	if the <link linkend="i-faddr">i_faddr</link> value is 0; in Ext4 this
	field is combined with <link linkend="l-i-frag">l_i_frag</link> to
	become the high 16bit of the 48bit blocks count for the inode data.
      </para></important>
     </sect4>
     <sect4 id="l-i-uid-high"><title>l_i_uid_high</title>
      <para>
	High 16bit of <link linkend="i-uid">user id</link>.
      </para>
     </sect4>
     <sect4 id="l-i-gid-high"><title>l_i_gid_high</title>
      <para>
	High 16bit of <link linkend="i-gid">group id</link>.
      </para>
     </sect4>
    </sect3>

    <sect3 id="i-osd2-masix"><title>Masix</title>
     <table id="i-osd2-masix-structure" frame="topbot" colsep="0" rowsep="0" pgwide="1">
      <title>Inode i_osd2 Structure: Masix</title>
      <tgroup cols="3">
       <colspec colwidth="20*" colname="c1" />
       <colspec colwidth="20*" colname="c2" />
       <colspec colwidth="60*" colname="c3" />
       <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
       <thead>
        <row>
         <entry>Offset (bytes)</entry>
         <entry>Size (bytes)</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>0</entry>
         <entry>1</entry>
         <entry><link linkend="m-i-frag">m_i_frag</link></entry>
        </row>
        <row>
         <entry>1</entry>
         <entry>1</entry>
         <entry><link linkend="m-i-fsize">m_i_fsize</link></entry>
        </row>
        <row>
         <entry>2</entry>
         <entry>10</entry>
         <entry>reserved</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <sect4 id="m-i-frag"><title>m_i_frag</title>
      <para>
	8bit fragment number.  Always 0 in Masix as framgents are not
	supported.  Obsolete with Ext4.
      </para>
     </sect4>
     <sect4 id="m-i-fsize"><title>m_i_fsize</title>
      <para>
	8bit fragment size.  Always 0 in Masix as fragments are not
	supported.  Obsolete with Ext4.
      </para>
     </sect4>
    </sect3>
   </sect2>
  </sect1>
  <sect1><title>Locating an Inode</title>
   <para>
	Inodes are all numerically ordered.  The <quote>inode number</quote> is
	an index in the	<link linkend="inode-table">inode table</link> to an
	<link linkend="inode-structure">inode</link> structure.  The size of the
	inode table	is fixed at format time; it is built to hold a maximum
	number of	entries.  Due to the large amount of entries
	created, the table is quite big and thus, it is split equally among
	all the <link linkend="block-group-descriptor-table">block groups</link>
	(see <xref linkend="disk-organisation" />	for more information).
   </para>
   <para>
	The <link linkend="s-inodes-per-group">s_inodes_per_group</link> field in
	the <link linkend="superblock">superblock</link> structure tells us how many
	inodes are defined per group.  Knowing that inode 1 is the first inode
	defined in the inode table, one can use the following formulaes:
   </para><programlisting>
block group = (inode - 1) / s_inodes_per_group
   </programlisting><para>
	Once the block is identified, the local inode index for the local inode
	table can be identified using:
   </para><programlisting>
local inode index = (inode - 1) % s_inodes_per_group
   </programlisting><para>
	Here are a couple of sample values that could be used to test
	your implementation:
   </para>
   <table id="inode-computation-sample" frame="topbot" colsep="0" rowsep="0" pgwide="1">
    <title>Sample Inode Computations</title>
    <tgroup cols="3">
     <colspec colwidth="40*" colname="c1" />
     <colspec colwidth="30*" colname="c2" />
     <colspec colwidth="30*" colname="c3" />
     <spanspec spanname="hdr" namest="c1" nameend="c3" />
     <thead>
      <row>
       <entry>Inode Number</entry>
       <entry>Block Group Number</entry>
       <entry>Local Inode Index</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry spanname="hdr">s_inodes_per_group = 1712</entry>
      </row>
      <row>
       <entry>1</entry>
       <entry>0</entry>
       <entry>0</entry>
      </row>
      <row>
       <entry>963</entry>
       <entry>0</entry>
       <entry>962</entry>
      </row>
      <row>
       <entry>1712</entry>
       <entry>0</entry>
       <entry>1711</entry>
      </row>
      <row>
       <entry>1713</entry>
       <entry>1</entry>
       <entry>0</entry>
      </row>
      <row>
       <entry>3424</entry>
       <entry>1</entry>
       <entry>1711</entry>
      </row>
      <row>
       <entry>3425</entry>
       <entry>2</entry>
       <entry>0</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
	As many of you are most likely already familiar with, an index of 0
	means the first entry.  The reason behind using 0 rather than 1 is that
	it can more easily be multiplied by the structure size to find the
	final byte offset of its location in memory or on disk.
   </para>
  </sect1>
 </chapter>

 <chapter id="directory"><title>Directory Structure</title>
  <para>
	Directories are used to hierarchically organize files.  Each directory
	can contain other directories, regular files and special files.
  </para>
  <para>
	Directories are stored as data block and referenced by an inode.  They
	can be identified by the file type
	<constant>EXT2_S_IFDIR</constant> stored in the <link linkend="i-mode">i_mode</link>
	field of the <link linkend="inode-structure">inode</link> structure.
  </para>
  <para>
	The second entry of the <link linkend="inode-table">Inode table</link> contains
	the inode pointing to the data of the root directory; as defined by the
	<constant>EXT2_ROOT_INO</constant> constant.
  </para>
  <para>
	In revision 0 directories could only be stored in a linked list.  Revision 1
	and later introduced indexed directories.  The indexed directory is backward
	compatible with the linked list directory; this is achieved by inserting
	empty directory entry records to skip over the hash indexes.
  </para>

  <sect1 id="linked-directories">
   <title>Linked List Directory</title>
   <para>
	A directory file is a linked list of 
	<link linkend="linked-directory-entry-structure">directory entry</link> 
	structures.  Each structure contains the name of the entry, the inode
	associated with the data of this entry, and the distance within the
	directory file to the next entry.
   </para>
   <para>
	In revision 0, the type of the entry (file, directory, special file, etc)
	has to be looked up in the inode of the file.  In revision 0.5 and later,
	the file type is also contained in the
	<link linkend="linked-directory-entry-structure">directory entry</link> structure.
   </para>

   <table id="linked-directory-entry-structure" frame="topbot" colsep="0" rowsep="0" pgwide="1">
    <title>Linked Directory Entry Structure</title>
    <tgroup cols="3">
     <colspec colwidth="20*" colname="c1" />
     <colspec colwidth="20*" colname="c2" />
     <colspec colwidth="60*" colname="c3" />
     <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
     <thead>
      <row>
       <entry>Offset (bytes)</entry>
       <entry>Size (bytes)</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>0</entry>
       <entry>4</entry>
       <entry><link linkend="ifdir-inode">inode</link></entry>
      </row>
      <row>
       <entry>4</entry>
       <entry>2</entry>
       <entry><link linkend="ifdir-rec-len">rec_len</link></entry>
      </row>
      <row>
       <entry>6</entry>
       <entry>1</entry>
       <entry><link linkend="ifdir-name-len">name_len</link><footnote>
        <para>
	Revision 0 of Ext2 used a 16bit <structfield>name_len</structfield>;
	since most implementations restricted filenames to a maximum of 255
	characters this value was truncated to 8bit with the upper 8bit
	recycled as <link linkend="ifdir-file-type">file_type</link>.
        </para>
       </footnote></entry>
      </row>
      <row>
       <entry>7</entry>
       <entry>1</entry>
       <entry><link linkend="ifdir-file-type">file_type</link><footnote>
        <para>
	Not available in revision 0; this field was part of the 16bit
	<link linkend="ifdir-name-len">name_len</link> field.
        </para>
       </footnote></entry>
      </row>
      <row>
       <entry>8</entry>
       <entry>0-255</entry>
       <entry><link linkend="ifdir-name">name</link></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <sect2 id="ifdir-inode"><title>inode</title>
    <para>
	32bit inode number of the file entry.  A value of 0 indicate that the entry
	is not used.
    </para>
   </sect2>

   <sect2 id="ifdir-rec-len"><title>rec_len</title>
    <para>
	16bit unsigned displacement to the next directory entry from the start of the
	current directory entry. This field must have a value at least equal to the
	length of the current record.
    </para>
    <para>
	The directory entries must be aligned on 4 bytes boundaries and there cannot
	be any directory entry spanning multiple data blocks.  If an entry cannot
	completely fit in one block, it must be pushed to the next data block and the
	rec_len of the previous entry properly adjusted.
    </para>
    <note>
     <para>
	Since this value cannot be negative, when a file is removed the previous
	record within the block has to be modified to point to the next valid record
	within the block or to the end of the block when no other directory entry is
	present.
     </para>
     <para>
	If the first entry within the block is removed, a blank record
	will be created and point to the next directory entry or to the end of the
	block.
     </para>
    </note>
   </sect2>

   <sect2 id="ifdir-name-len"><title>name_len</title>
    <para>
	8bit unsigned value indicating how many bytes of character data are contained in the name.
    </para>
    <note>
     <para>
	This value must never be larger than rec_len - 8.  If the directory entry
	name is updated and cannot fit in the existing directory entry, the entry may
	have to be relocated in a new directory entry of sufficient size and
	possibly stored in a new data block.
     </para>
    </note>
   </sect2>

   <sect2 id="ifdir-file-type"><title>file_type</title>
    <para>
	8bit unsigned value used to indicate file type.
    </para>
    <note>
     <para>
	In revision 0, this field was the upper 8-bit of the then 16-bit name_len.  
	Since all implementations still limited the file names to 255 characters this
	8-bit value was always 0.
     </para>
     <para>
	This value must match the inode type defined in the related inode entry.
     </para>
    </note>
    <table id="ifdir-file-type-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Defined Inode File Type Values</title>
     <tgroup cols="3" align="left">
      <colspec colwidth="40*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="40*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" align="center" />
      <thead>
       <row>
        <entry>Constant Name</entry>
        <entry>Value</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row><entry>EXT2_FT_UNKNOWN</entry><entry>0</entry><entry>Unknown File Type</entry></row>
       <row><entry>EXT2_FT_REG_FILE</entry><entry>1</entry><entry>Regular File</entry></row>
       <row><entry>EXT2_FT_DIR</entry><entry>2</entry><entry>Directory File</entry></row>
       <row><entry>EXT2_FT_CHRDEV</entry><entry>3</entry><entry>Character Device</entry></row>
       <row><entry>EXT2_FT_BLKDEV</entry><entry>4</entry><entry>Block Device</entry></row>
       <row><entry>EXT2_FT_FIFO</entry><entry>5</entry><entry>Buffer File</entry></row>
       <row><entry>EXT2_FT_SOCK</entry><entry>6</entry><entry>Socket File</entry></row>
       <row><entry>EXT2_FT_SYMLINK</entry><entry>7</entry><entry>Symbolic Link</entry></row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="ifdir-name"><title>name</title>
    <para>
	Name of the entry.  The ISO-Latin-1 character set is expected in most system.
	The name must be no longer than 255	bytes after encoding.
    </para>
   </sect2>

   <sect2 id="dir-sample"><title>Sample Directory</title>
    <para>
	Here's a sample of the home directory of one user on my system:
    </para>
    <programlisting>
$ ls -1a ~
.
..
.bash_profile
.bashrc
mbox
public_html
tmp
    </programlisting>
    <para>
	For which the following data representation can be found on the storage
	device:
    </para>
    <table id="sample-linked-directory-data" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Sample Linked Directory Data Layout, 4KiB blocks</title>
     <tgroup cols="3">
      <colspec colwidth="20*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="60*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
      <thead>
       <row>
        <entry>Offset (bytes)</entry>
        <entry>Size (bytes)</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry spanname="hdr" rowsep="1">Directory Entry 0</entry>
       </row>
       <row>
        <entry>0</entry>
        <entry>4</entry>
        <entry>inode number: 783362</entry>
       </row>
       <row>
        <entry>4</entry>
        <entry>2</entry>
        <entry>record length: 12</entry>
       </row>
       <row>
        <entry>6</entry>
        <entry>1</entry>
        <entry>name length: 1</entry>
       </row>
       <row>
        <entry>7</entry>
        <entry>1</entry>
        <entry>file type: <constant>EXT2_FT_DIR</constant>=2</entry>
       </row>
       <row>
        <entry>8</entry>
        <entry>1</entry>
        <entry>name: .</entry>
       </row>
       <row>
        <entry>9</entry>
        <entry>3</entry>
        <entry>padding</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">Directory Entry 1</entry>
       </row>
       <row>
        <entry>12</entry>
        <entry>4</entry>
        <entry>inode number: 1109761</entry>
       </row>
       <row>
        <entry>16</entry>
        <entry>2</entry>
        <entry>record length: 12</entry>
       </row>
       <row>
        <entry>18</entry>
        <entry>1</entry>
        <entry>name length: 2</entry>
       </row>
       <row>
        <entry>19</entry>
        <entry>1</entry>
        <entry>file type: <constant>EXT2_FT_DIR</constant>=2</entry>
       </row>
       <row>
        <entry>20</entry>
        <entry>2</entry>
        <entry>name: ..</entry>
       </row>
       <row>
        <entry>22</entry>
        <entry>2</entry>
        <entry>padding</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">Directory Entry 2</entry>
       </row>
       <row>
        <entry>24</entry>
        <entry>4</entry>
        <entry>inode number: 783364</entry>
       </row>
       <row>
        <entry>28</entry>
        <entry>2</entry>
        <entry>record length: 24</entry>
       </row>
       <row>
        <entry>30</entry>
        <entry>1</entry>
        <entry>name length: 13</entry>
       </row>
       <row>
        <entry>31</entry>
        <entry>1</entry>
        <entry>file type: <constant>EXT2_FT_REG_FILE</constant></entry>
       </row>
       <row>
        <entry>32</entry>
        <entry>13</entry>
        <entry>name: .bash_profile</entry>
       </row>
       <row>
        <entry>45</entry>
        <entry>3</entry>
        <entry>padding</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">Directory Entry 3</entry>
       </row>
       <row>
        <entry>48</entry>
        <entry>4</entry>
        <entry>inode number: 783363</entry>
       </row>
       <row>
        <entry>52</entry>
        <entry>2</entry>
        <entry>record length: 16</entry>
       </row>
       <row>
        <entry>54</entry>
        <entry>1</entry>
        <entry>name length: 7</entry>
       </row>
       <row>
        <entry>55</entry>
        <entry>1</entry>
        <entry>file type: <constant>EXT2_FT_REG_FILE</constant></entry>
       </row>
       <row>
        <entry>56</entry>
        <entry>7</entry>
        <entry>name: .bashrc</entry>
       </row>
       <row>
        <entry>63</entry>
        <entry>1</entry>
        <entry>padding</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">Directory Entry 4</entry>
       </row>
       <row>
        <entry>64</entry>
        <entry>4</entry>
        <entry>inode number: 783377</entry>
       </row>
       <row>
        <entry>68</entry>
        <entry>2</entry>
        <entry>record length: 12</entry>
       </row>
       <row>
        <entry>70</entry>
        <entry>1</entry>
        <entry>name length: 4</entry>
       </row>
       <row>
        <entry>71</entry>
        <entry>1</entry>
        <entry>file type: <constant>EXT2_FT_REG_FILE</constant></entry>
       </row>
       <row>
        <entry>72</entry>
        <entry>4</entry>
        <entry>name: mbox</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">Directory Entry 5</entry>
       </row>
       <row>
        <entry>76</entry>
        <entry>4</entry>
        <entry>inode number: 783545</entry>
       </row>
       <row>
        <entry>80</entry>
        <entry>2</entry>
        <entry>record length: 20</entry>
       </row>
       <row>
        <entry>82</entry>
        <entry>1</entry>
        <entry>name length: 11</entry>
       </row>
       <row>
        <entry>83</entry>
        <entry>1</entry>
        <entry>file type: <constant>EXT2_FT_DIR</constant>=2</entry>
       </row>
       <row>
        <entry>84</entry>
        <entry>11</entry>
        <entry>name: public_html</entry>
       </row>
       <row>
        <entry>95</entry>
        <entry>1</entry>
        <entry>padding</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">Directory Entry 6</entry>
       </row>
       <row>
        <entry>96</entry>
        <entry>4</entry>
        <entry>inode number: 669354</entry>
       </row>
       <row>
        <entry>100</entry>
        <entry>2</entry>
        <entry>record length: 12</entry>
       </row>
       <row>
        <entry>102</entry>
        <entry>1</entry>
        <entry>name length: 3</entry>
       </row>
       <row>
        <entry>103</entry>
        <entry>1</entry>
        <entry>file type: <constant>EXT2_FT_DIR</constant>=2</entry>
       </row>
       <row>
        <entry>104</entry>
        <entry>3</entry>
        <entry>name: tmp</entry>
       </row>
       <row>
        <entry>107</entry>
        <entry>1</entry>
        <entry>padding</entry>
       </row>
       <row>
        <entry spanname="hdr" rowsep="1">Directory Entry 7</entry>
       </row>
       <row>
        <entry>108</entry>
        <entry>4</entry>
        <entry>inode number: 0</entry>
       </row>
       <row>
        <entry>112</entry>
        <entry>2</entry>
        <entry>record length: 3988</entry>
       </row>
       <row>
        <entry>114</entry>
        <entry>1</entry>
        <entry>name length: 0</entry>
      </row>
       <row>
        <entry>115</entry>
        <entry>1</entry>
        <entry>file type: <constant>EXT2_FT_UNKNOWN</constant></entry>
       </row>
       <row>
        <entry>116</entry>
        <entry>0</entry>
        <entry>name:</entry>
       </row>
       <row>
        <entry>116</entry>
        <entry>3980</entry>
        <entry>padding</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>
  </sect1>

  <sect1 id="indexed-directory"><title>Indexed Directory Format</title>
   <para>
	Using the standard linked list directory format can become very slow
	once the number of files starts growing.  To improve performances in
	such a system, a hashed index is used, which allow to quickly
	locate the particular file searched.
   </para>
   <para>
	Bit <link linkend="ext2-index-fl">EXT2_INDEX_FL</link> in the
	<link linkend="i-flags">i_flags</link> of the directory inode
	is set if the indexed directory format is used.
   </para>
   <para>
	In order to maintain backward compatibility with older implementations,
	the indexed directory also maintains a linked directory format side-by-side.
	In case there's any discrepency between the indexed and linked directories,
	the linked directory is preferred.
   </para>
   <para>
	This backward compatibility is achieved by placing a fake directory entries
	at the beginning of block 0 of the indexed directory data blocks.  These
	fake entries are part of the <link linkend="dx-root-structure">dx_root</link>
	structure and host the linked directory information for the "." and ".."
	folder entries.
   </para>
   <para>
	Immediately following the <xref linkend="dx-root" /> structure is an array
	of <xref linkend="dx-entry" /> up to the end of the data block or until
	all files have been indexed.
   </para>
   <para>
	When the number of files to be indexed exceeds the number of <xref linkend="dx-entry" />
	that can fit in a block (<xref linkend="dx-entry-countlimit-limit" />), a level
	of indirect indexes is created.  An indirect index is another data block allocated
	to the directory inode that contains directory entries.
   </para>

   <sect2 id="dx-root"><title>Indexed Directory Root</title>
    <table id="dx-root-structure" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Indexed Directory Root Structure</title>
     <tgroup cols="3">
      <colspec colwidth="20*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="60*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
      <thead>
       <row>
        <entry>Offset (bytes)</entry>
        <entry>Size (bytes)</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry spanname="hdr">-- Linked Directory Entry: . --</entry>
       </row><row>
        <entry>0</entry>
        <entry>4</entry>
        <entry>inode: this directory</entry>
       </row><row>
        <entry>4</entry>
        <entry>2</entry>
        <entry>rec_len: 12</entry>
       </row><row>
        <entry>6</entry>
        <entry>1</entry>
        <entry>name_len: 1</entry>
       </row><row>
        <entry>7</entry>
        <entry>1</entry>
        <entry>file_type: <constant>EXT2_FT_DIR</constant>=2</entry>
       </row><row>
        <entry>8</entry>
        <entry>1</entry>
        <entry>name: .</entry>
       </row><row>
        <entry>9</entry>
        <entry>3</entry>
        <entry>padding</entry>
       </row><row>
        <entry spanname="hdr">-- Linked Directory Entry: .. --</entry>
       </row><row>
        <entry>12</entry>
        <entry>4</entry>
        <entry>inode: parent directory</entry>
       </row><row>
        <entry>16</entry>
        <entry>2</entry>
        <entry>rec_len: (blocksize - this entry's length(12))</entry>
       </row><row>
        <entry>18</entry>
        <entry>1</entry>
        <entry>name_len: 2</entry>
       </row><row>
        <entry>19</entry>
        <entry>1</entry>
        <entry>file_type: <constant>EXT2_FT_DIR</constant>=2</entry>
       </row><row>
        <entry>20</entry>
        <entry>2</entry>
        <entry>name: ..</entry>
       </row><row>
        <entry>22</entry>
        <entry>2</entry>
        <entry>padding</entry>
       </row><row>
        <entry spanname="hdr">-- Indexed Directory Root Information Structure --</entry>
       </row><row>
        <entry>24</entry>
        <entry>4</entry>
        <entry>reserved, zero</entry>
       </row><row>
        <entry>28</entry>
        <entry>1</entry>
        <entry><link linkend="dx-hash-version">hash_version</link></entry>
       </row><row>
        <entry>29</entry>
        <entry>1</entry>
        <entry><link linkend="dx-info-length">info_length</link></entry>
       </row><row>
        <entry>30</entry>
        <entry>1</entry>
        <entry><link linkend="dx-indirect-levels">indirect_levels</link></entry>
       </row><row>
        <entry>31</entry>
        <entry>1</entry>
        <entry>reserved - unused flags</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <sect3 id="dx-hash-version"><title>hash_version</title>
     <para>
	8bit value representing the hash version used in this indexed directory.
     </para>
     <table id="defined-dx-hash-version-values" frame="topbot" colsep="0" rowsep="0" pgwide="1">
      <title>Defined Indexed Directory Hash Versions</title>
      <tgroup cols="3">
       <colspec colwidth="40*" colname="c1" />
       <colspec colwidth="20*" colname="c2" />
       <colspec colwidth="40*" colname="c3" />
       <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
       <thead>
        <row>
         <entry>Constant Name</entry>
         <entry>Value</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>DX_HASH_LEGACY</entry>
         <entry>0</entry>
         <entry>TODO: link to section</entry>
        </row><row>
         <entry>DX_HASH_HALF_MD4</entry>
         <entry>1</entry>
         <entry>TODO: link to section</entry>
        </row><row>
         <entry>DX_HASH_TEA</entry>
         <entry>2</entry>
         <entry>TODO: link to section</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </sect3>

    <sect3 id="dx-info-length"><title>info_length</title>
     <para>
	8bit length of the indexed directory information structure (dx_root); 
	currently equal to 8.
     </para>
    </sect3>

    <sect3 id="dx-indirect-levels"><title>indirect_levels</title>
     <para>
	8bit value indicating how many indirect levels of indexing are present in
	this hash.
     </para>
     <note><para>
	In Linux, as of 2.6.28, the maximum indirect levels value supported is 1.
     </para></note>
    </sect3>
   </sect2>

   <sect2 id="dx-entry"><title>Indexed Directory Entry</title>
    <para>
	The indexed directory entries are used to quickly lookup the inode number
	associated with the hash of a filename.  These entries are located immediately
	following the fake linked directory entry of the directory data blocks, or
	immediately following the <xref linkend="dx-root" />.
    </para>
    <para>
	The first indexed directory entry, rather than containing an actual hash and
	block	number, contains the maximum number of indexed directory entries that
	can fit in the block and the actual number of indexed directory entries 
	stored in the block.	The format of this special entry is detailed in
	<xref linkend="dx-entry-countlimit" />.
    </para>
    <para>
	The other directory entries are sorted by hash value starting from the 
	smallest to the largest numerical value.
    </para>
    <table id="dx-entry-structure" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Indexed Directory Entry Structure (dx_entry)</title>
     <tgroup cols="3">
      <colspec colwidth="20*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="60*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" align="left" />
      <thead>
       <row>
        <entry>Offset (bytes)</entry>
        <entry>Size (bytes)</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>0</entry>
        <entry>4</entry>
        <entry><link linkend="dx-entry-hash">hash</link></entry>
       </row>
       <row>
        <entry>4</entry>
        <entry>4</entry>
        <entry><link linkend="dx-entry-block">block</link></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="dx-entry-countlimit" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Indexed Directory Entry Count and Limit Structure</title>
     <tgroup cols="3">
      <colspec colwidth="20*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="60*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" />
      <thead>
       <row>
        <entry>Offset (bytes)</entry>
        <entry>Size (bytes)</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>0</entry>
        <entry>2</entry>
        <entry><link linkend="dx-entry-countlimit-limit">limit</link></entry>
       </row>
       <row>
        <entry>2</entry>
        <entry>2</entry>
        <entry><link linkend="dx-entry-countlimit-count">count</link></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <sect3 id="dx-entry-hash"><title>hash</title>
     <para>
	32bit hash of the filename represented by this entry.
     </para>
    </sect3>

    <sect3 id="dx-entry-block"><title>block</title>
     <para>
	32bit block index of the directory inode data block containing the (linked) directory entry for the filename.
     </para>
    </sect3>

    <sect3 id="dx-entry-countlimit-limit"><title>limit</title>
     <para>
	16bit value representing the total number of indexed directory entries that
	fit within the block, after removing the other structures, but including
	the count/limit entry.
     </para>
    </sect3>

    <sect3 id="dx-entry-countlimit-count"><title>count</title>
     <para>
	16bit value representing the total number of indexed directory entries
	present in the block. TODO: Research if this value includes the count/limit entry.
     </para>
    </sect3>
   </sect2>

   <sect2 id="contrib-lookup-algorithm"><title>Lookup Algorithm</title>
    <para>
	Lookup is straightforword:
    </para><programlisting>
- Compute a hash of the name
- Read the index root
- Use binary search (linear in the current code) to find the
  first index or leaf block that could contain the target hash
  (in tree order)
- Repeat the above until the lowest tree level is reached
- Read the leaf directory entry block and do a normal Ext2
  directory block search in it.
- If the name is found, return its directory entry and buffer
- Otherwise, if the collision bit of the next directory entry is
  set, continue searching in the successor block
    </programlisting><para>
	Normally, two logical blocks of the file will need to be accessed, and
	one or two metadata index blocks.  The effect of the metadata index
	blocks can largely be ignored in terms of disk access time since these
	blocks are unlikely to be evicted from cache.  There is some small CPU
	cost that can be addressed by moving the whole directory into the page
	cache.
    </para>
   </sect2>

   <sect2 id="contrib-insert-algorithm"><title>Insert Algorithm</title>
    <para>
	Insertion of new entries into the directory is considerably more
	complex than lookup, due to the need to split leaf blocks when they
	become full, and to satisfy the conditions that allow hash key
	collisions to be handled reliably and efficiently.  I'll just summarize
	here:
    </para><programlisting>
- Probe the index as for lookup
- If the target leaf block is full, split it and note the block
  that will receive the new entry
- Insert the new entry in the leaf block using the normal Ext2
  directory entry insertion code.
    </programlisting><para>
	The details of splitting and hash collision handling are somewhat
	messy, but I will be happy to dwell on them at length if anyone is
	interested.
    </para>
   </sect2>

   <sect2 id="contrib-splitting"><title>Splitting</title>
    <para>
	In brief, when a leaf node fills up and we want to put a new entry into
	it the leaf has to be split, and its share of the hash space has to
	be partitioned.  The most straightforward way to do this is to sort the
	entrys by hash value and split somewhere in the middle of the sorted
	list.  This operation is log(number_of_entries_in_leaf) and is not a
	great cost so long as an efficient sorter is used.  I used Combsort
	for this, although Quicksort would have been just as good in this
	case since average case performance is more important than worst case. 
    </para><para>
	An alternative approach would be just to guess a median value for the
	hash key, and the partition could be done in linear time, but the
	resulting poorer partitioning of hash key space outweighs the small
	advantage of the linear partition algorithm.  In any event, the number
	of entries needing sorting is bounded by the number that fit in a leaf.
    </para>
   </sect2>

   <sect2 id="contrib-key-collisions"><title>Key Collisions</title>
    <para>
	Some complexity is introduced by the need to handle sequences of hash
	key collisions.  It is desireable to avoid splitting such sequences
	between blocks, so the split point of a block is adjusted with this in
	mind.  But the possibility still remains that if the block fills up
	with identically-hashed entries, the sequence may still have to be
	split.  This situation is flagged by placing a 1 in the low bit of the
	index entry that points at the sucessor block, which is naturally
	interpreted by the index probe as an intermediate value without any
	special coding.  Thus, handling the collision problem imposes no real
	processing overhead, just come extra code and a slight reduction in the
	hash key space.  The hash key space remains  sufficient for any
	conceivable number of directory entries, up into the billions.
    </para>
   </sect2>

   <sect2 id="contrib-hash-function"><title>Hash Function</title>
    <para>
	The exact properties of the hash function critically affect the
	performance of this indexing strategy, as I learned by trying a number
	of poor hash functions, at times intentionally.  A poor hash function
	will result in many collisions or poor partitioning of the hash space. 
	To illustrate why the latter is a problem, consider what happens when a
	block is split such that it covers just a few distinct hash values. 
	The probability of later index entries hashing into the same, small
	hash space is very small.  In practice, once a block is split, if its
	hash space is too small it tends to stay half full forever, an effect I
	observed in practice.
    </para><para>
	After some experimentation I came up with a hash function that gives
	reasonably good dispersal of hash keys across the entire 31 bit key
	space.  This improved the average fullness of leaf blocks considerably,
	getting much closer to the theoretical average of 3/4 full.
    </para><para>
	But the current hash function is just a place holder, waiting for
	an better version based on some solid theory.  I currently favor the
	idea of using crc32 as the default hash function, but I welcome
	suggestions.
    </para><para>
	Inevitably, no matter how good a hash function I come up with, somebody
	will come up with a better one later.  For this reason the design
	allows for additional hash functiones to be added, with backward
	compatibility.  This is accomplished simply, by including a hash
	function number in the index root.  If a new, improved hash function is
	added, all the previous versions remain available, and previously
	created indexes remain readable.
    </para><para>
	Of course, the best strategy is to have a good hash function right from
	the beginning.  The initial, quick hack has produced results that
	certainly have not been disappointing.
    </para>
   </sect2>

   <sect2 id="contrib-performance"><title>Performance</title>
    <para>
	OK, if you have read this far then this is no doubt the part you've
	been waiting for.  In short, the performance improvement over normal
	Ext2 has been stunning.  With very small directories performance is
	similar to standard Ext2, but as directory size increases standard
	Ext2 quickly blows up quadratically, while htree-enhanced Ext2
	continues to scale linearly.
    </para><para>
	Uli Luckas ran benchmarks for file creation in various sizes of
	directories ranging from 10,000 to 90,000 files.  The results are
	pleasing: total file creation time stays very close to linear, versus
	quadratic increase with normal Ext2.
    </para><para>
	Time to create:
    </para><figure><title>Performance of Indexed Directories</title><programlisting>
		Indexed		Normal
		=======		======
10000 Files:	0m1.350s	0m23.670s
20000 Files:	0m2.720s	1m20.470s
30000 Files:	0m4.330s	3m9.320s
40000 Files:	0m5.890s	5m48.750s
50000 Files:	0m7.040s	9m31.270s
60000 Files:	0m8.610s	13m52.250s
70000 Files:	0m9.980s	19m24.070s
80000 Files:	0m12.060s	25m36.730s
90000 Files:	0m13.400s	33m18.550s
    </programlisting></figure><para>
    The original paper by Daniel Phillips is at https://www.kernel.org/doc/ols/2002/ols2002-pages-425-438.pdf
    </para><para>
	All of these tests are CPU-bound, which may come as a surprise.  The
	directories fit easily in cache, and the limiting factor in the case of
	standard Ext2 is the looking up of directory blocks in buffer cache,
	and the low level scan of directory entries.  In the case of htree
	indexing there are a number of costs to be considered, all of them
	pretty well bounded.  Notwithstanding, there are a few obvious
	optimizations to be done:
    </para><programlisting>
- Use binary search instead of linear search in the interior index
  nodes.

- If there is only one leaf block in a directory, bypass the index
  probe, go straight to the block.

- Map the directory into the page cache instead of the buffer cache.
    </programlisting><para>
	Each of these optimizations will produce a noticeable improvement in
	performance, but naturally it will never be anything like the big jump
	going from N**2 to Log512(N), ~= N.  In time the optimizations will be
	applied and we can expect to see another doubling or so in performance.
    </para><para>
	There will be a very slight performance hit when the directory gets big
	enough to need a second level.  Because of caching this will be very
	small.  Traversing the directories metadata index blocks will be a
	bigger cost, and once again, this cost can be reduced by moving the
	directory blocks into the page cache.
    </para><para>
	Typically, we will traverse 3 blocks to read or write a directory
	entry, and that number increases to 4-5 with really huge directories. 
	But this is really nothing compared to normal Ext2, which traverses
	several hundred blocks in the same situation.
    </para>
   </sect2>
  </sect1>
 </chapter>


 <chapter><title>File Attributes</title>
  <para>
	Most of the file (also directory, symlink, device...) attributes are
	located in the <link linkend="inode-table">inode</link> associated with the file.
	Some other attributes are only available as extended attributes.
  </para>

  <sect1><title>Standard Attributes</title>
    <sect2><title>SUID, SGID and -rwxrwxrwx</title>
    <para>
	There isn't much to say about those, they are located with the SGID and SUID bits in
	<link linkend="i-mode">ext2_inode.i_mode</link>.
    </para>
   </sect2>

   <sect2><title>File Size</title>
    <para>
	The size of a file can be determined by looking at the
	<link linkend="i-size">ext2_inode.i_size</link> field.
    </para>
   </sect2>

   <sect2><title>Owner and Group</title>
    <para>
	Under most implementations, the owner and group are 16bit values, but on
	some recent Linux and Hurd implementations the owner and group id are
	32bit.  When 16bit values are used, only the <quote>low</quote> part should
	be used as valid, while when using 32bit value, both the <quote>low</quote>
	and <quote>high</quote> part should be used, the high part being shifted left
	16 places then added to the low part.
    </para>
    <para>
	The low part of owner and group are located in
	<link linkend="i-uid">ext2_inode.i_uid</link> and
	<link linkend="i-gid">ext2_inode.i_gid</link> respectively.
    </para>
    <para>
	The high part of owner and group are located in
	<link linkend="h-i-uid-high">ext2_inode.osd2.hurd.h_i_uid_high</link> and
	<link linkend="l-i-gid-high">ext2_inode.osd2.hurd.h_i_gid_high</link>,
	respectively, for Hurd and located in
	<link linkend="l-i-uid-high">ext2_inode.osd2.linux.l_i_uid_high</link> and
	<link linkend="l-i-gid-high">ext2_inode.osd2.linux.l_i_gid_high</link>,
	respectively, for Linux.
    </para>
   </sect2>
  </sect1>

  <sect1 id="contrib-extended-attributes"><title>Extended Attributes</title>
   <para>
	Extended attributes are name:value pairs associated  permanently  with
	files and directories, similar to the environment  strings  associated
	with a process.  An attribute may be defined or undefined.  If  it  is
	defined, its value  may	be empty or non-empty.
   </para>
   <para>
	Extended attributes are extensions to the normal attributes which  are
	associated with all inodes in the  system.  They  are  often  used  to
	provide additional  functionality  to  a  filesystem  -  for  example, 
	additional security features such as Access Control Lists  (ACLs)  may
	be implemented using extended attributes.
   </para>
   <para>
	Extended attributes are accessed as atomic objects. Reading  retrieves
	the whole value of an attribute and stores it  in  a  buffer.  Writing
	replaces any previous value with the new value.
   </para>
   <para>
	Extended attributes are stored on disk blocks allocated outside of
	any inode. The <link linkend="i-file-acl">i_file_acl</link> field (for
	regular files) or the <link linkend="i-dir-acl">i_dir_acl</link> field
	(for directories) fields contain the block number of the allocated data
	block used to store the	extended attributes.
   </para>
   <note><para>
	Inodes which have all identical extended attributes may share the same
	extended attribute block.
   </para></note>
   <para>
	The attribute values are on the  same block  as their  attribute entry
	descriptions, aligned to the end of the  attribute block.  This allows
	for additional attributes to be added more easily. The  size  of  entry
	headers  varies with  the length  of the	attribute name.
   </para>

   <sect2 id="extended-attribute-layout">
    <title>Extended Attribute Block Layout</title>
    <para>
	The block header is followed by multiple entry descriptors. These entry
	descriptors are variable in size, and aligned to <constant>EXT2_XATTR_PAD</constant>
	(4) byte boundaries. The entry descriptors are sorted by attribute name,
	so that two extended attribute blocks can be compared efficiently.
    </para>
    <para>
	Attribute values are aligned to the end of the block, stored in
	no specific order. They are also padded to <constant>EXT2_XATTR_PAD</constant> (4)
	byte boundaries. No additional gaps are left between them.
    </para>
    <table id="extended-attribute-block-layout" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>Extended Attribute Block Layout</title>
     <tgroup cols="3">
      <colspec colwidth="40*" colname="c1" />
      <colspec colwidth="5*" colname="c2" align="center" />
      <colspec colwidth="55*" colname="c3" />
      <tbody>
       <row>
        <entry>Attribute Block Header</entry>
       </row>
       <row>
        <entry>Attribute Entry 1</entry><entry>|</entry>
       </row>
       <row>
        <entry>Attribute Entry 2</entry><entry>|</entry><entry>growing downwards</entry>
       </row>
       <row>
        <entry>Attribute Entry 3</entry><entry>V</entry>
       </row>
       <row>
        <entry>4 null bytes</entry>
       </row>
       <row>
        <entry>unused space...</entry>
       </row>
       <row>
        <entry>Attribute Value 1</entry><entry>^</entry>
       </row>
       <row>
        <entry>Attribute Value 3</entry><entry>|</entry><entry>growing upwards</entry>
       </row>
       <row>
        <entry>Attribute Value 2</entry><entry>|</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="attribute-block-header"><title>Extended Attribute Block Header</title>
    <table id="attribute-block-header-structure" frame="topbot" colsep="0" rowsep="0" pgwide="1">
     <title>ext2_xattr_header structure</title>
     <tgroup cols="3">
      <colspec colwidth="20*" colname="c1" />
      <colspec colwidth="20*" colname="c2" />
      <colspec colwidth="60*" colname="c3" />
      <spanspec spanname="hdr" namest="c1" nameend="c3" align="center" />
      <thead>
       <row>
        <entry>Offset (bytes)</entry>
        <entry>Size (bytse)</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>0</entry>
        <entry>4</entry>
        <entry><link linkend="xattr-h-magic">h_magic</link></entry>
       </row>
       <row>
        <entry>4</entry>
        <entry>4</entry>
        <entry><link linkend="xattr-h-refcount">h_refcount</link></entry>
       </row>
       <row>
        <entry>8</entry>
        <entry>4</entry>
        <entry><link linkend="xattr-h-blocks">h_blocks</link></entry>
       </row>
       <row>
        <entry>12</entry>
        <entry>4</entry>
        <entry><link linkend="xattr-h-hash">h_hash</link></entry>
       </row>
       <row>
        <entry>16</entry>
        <entry>16</entry>
        <entry>reserved</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    <sect3 id="xattr-h-magic"><title>h_magic</title>
     <para>
	32bit magic number of identification, <constant>EXT2_XATTR_MAGIC</constant> = 0xEA020000.
     </para>
    </sect3>
    <sect3 id="xattr-h-refcount"><title>h_refcount</title>
     <para>
	32bit value used as reference count.  This value is incremented everytime
	a link is created to this attribute block and decremented when a link is
	destroyed.  Whenever this value reaches 0 the attribute block can be freed.
     </para>
    </sect3>
    <sect3 id="xattr-h-blocks"><title>h_blocks</title>
     <para>
	32bit value indicating how many blocks are currently used by the
	extended attributes.
     </para>
     <note><para>
	In Linux a value of h_blocks higher than 1 is considered invalid.  This
	effectively restrict the amount of extended attributes to what can be
	fit in a single block.
     </para><para>
	There does not seem to be any support for extended attributes in Ext2 under
	GNU HURD.
     </para></note>
    </sect3>
    <sect3 id="xattr-h-hash"><title>h_hash</title>
     <para>
	32bit hash value of all attribute entry header hashes.
     </para>
     <procedure id="xattr-h-hash-procedure">
      <title>Procedure to compute Extended Attribute Header Hash</title>

      <step><para>Initialize the 32bit hash to 0</para></step>

      <step id="xattr-h-hash-procedure-loop"><para>Check if there are any extended 
	attribute entry to process, if not we are done.</para></step>

      <step><para>Do a cyclic bit shift of 16 bits to the left of the
	32bits hash value, effectively swapping the upper and lower 16bits of the hash</para></step>

	<step><para>Perform a bitwise OR between the extended attribute entry
	<link linkend="xattr-e-hash">hash</link> and the header hash being computed.</para></step>

      <step><para>Go back to <xref linkend="xattr-h-hash-procedure-loop" />.</para></step>

     </procedure>
    </sect3>
   </sect2>

   <sect2><title>Attribute Entry Header</title>
    <figure><title>ext2_xattr_header structure</title><programlisting>
offset  size    description
------- ------- -----------
      0       1 <link linkend="xattr-e-name-len">e_name_len</link>
      1       1 <link linkend="xattr-e-name-index">e_name_index</link>
      2       2 <link linkend="xattr-e-value-offs">e_value_offs</link>
      4       4 <link linkend="xattr-e-value-block">e_value_block</link>
      8       4 <link linkend="xattr-e-value-size">e_value_size</link>
     12       4 <link linkend="xattr-e-hash">e_hash</link>
     16     ... <link linkend="xattr-e-name">e_name</link>
    </programlisting></figure>
    <para>
	The total size of an attribute entry is always rounded to the
	next 4-bytes boundary.
    </para>
    <sect3 id="xattr-e-name-len"><title>e_name_len</title>
     <para>
	8bit unsigned value indicating the length of the name.
     </para>
    </sect3>
    <sect3 id="xattr-e-name-index"><title>e_name_index</title>
     <para>
	8bit unsigned value used as attribute name index.
     </para>
    </sect3>
    <sect3 id="xattr-e-value-offs"><title>e_value_offs</title>
     <para>
	16bit unsigned offset to the value within the value block.
     </para>
    </sect3>
    <sect3 id="xattr-e-value-block"><title>e_value_block</title>
     <para>
	32bit id of the block holding the value.
     </para>
    </sect3>
    <sect3 id="xattr-e-value-size"><title>e_value_size</title>
     <para>
	32bit unsigned value indicating the size of the attribute value.
     </para>
    </sect3>
    <sect3 id="xattr-e-hash"><title>e_hash</title>
     <para>
	32bit hash of attribute name and value.
     </para>
    </sect3>
    <sect3 id="xattr-e-name"><title>e_name</title>
     <para>
	Attribute name.
     </para>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="behaviour-flags"><title>Behaviour Control Flags</title>
   <para>
	The <link linkend="i-flags">i_flags</link> value in the
	<link linkend="inode-structure">inode</link> structure allows to  specify how the
	file system should behave in regard to the file.  The following bits
	are currently defined:
   </para>
   <table pgwide="1" frame="topbot" colsep="0" rowsep="0">
   <title>Behaviour Control Flags</title>
   <tgroup cols="3" align="left" >
   <colspec colwidth="40*" />
   <colspec colwidth="20*" />
   <colspec colwidth="40*" />
   <tbody>
   <row><entry><link linkend="ext2-secrm-fl">EXT2_SECRM_FL</link></entry><entry>0x00000001</entry><entry>secure deletion</entry></row>
   <row><entry><link linkend="ext2-unrm-fl">EXT2_UNRM_FL</link></entry><entry>0x00000002</entry><entry>record for undelete</entry></row>
   <row><entry><link linkend="ext2-compr-fl">EXT2_COMPR_FL</link></entry><entry>0x00000004</entry><entry>compressed file</entry></row>
   <row><entry><link linkend="ext2-sync-fl">EXT2_SYNC_FL</link></entry><entry>0x00000008</entry><entry>synchronous updates</entry></row>
   <row><entry><link linkend="ext2-immutable-fl">EXT2_IMMUTABLE_FL</link></entry><entry>0x00000010</entry><entry>immutable file</entry></row>
   <row><entry><link linkend="ext2-append-fl">EXT2_APPEND_FL</link></entry><entry>0x00000020</entry><entry>append only</entry></row>
   <row><entry><link linkend="ext2-nodump-fl">EXT2_NODUMP_FL</link></entry><entry>0x00000040</entry><entry>do not dump/delete file</entry></row>
   <row><entry><link linkend="ext2-noatime-fl">EXT2_NOATIME_FL</link></entry><entry>0x00000080</entry><entry>do not update .i_atime</entry></row>
   <row><entry><link linkend="ext2-dirty-fl">EXT2_DIRTY_FL</link></entry><entry>0x00000100</entry><entry>dirty (file is in use?)</entry></row>
   <row><entry><link linkend="ext2-comprblk-fl">EXT2_COMPRBLK_FL</link></entry><entry>0x00000200</entry><entry>compressed blocks</entry></row>
   <row><entry><link linkend="ext2-nocompr-fl">EXT2_NOCOMPR_FL</link></entry><entry>0x00000400</entry><entry>access raw compressed data</entry></row>
   <row><entry><link linkend="ext2-ecompr-fl">EXT2_ECOMPR_FL</link></entry><entry>0x00000800</entry><entry>compression error</entry></row>
   <row><entry><link linkend="ext2-btree-fl">EXT2_BTREE_FL</link></entry><entry>0x00001000</entry><entry>b-tree format directory</entry></row>
   <row><entry><link linkend="ext2-index-fl">EXT2_INDEX_FL</link></entry><entry>0x00001000</entry><entry>Hash indexed directory</entry></row>
   <row><entry><link linkend="ext2-imagic-fl">EXT2_IMAGIC_FL</link></entry><entry>0x00002000</entry><entry>?</entry></row>
   <row><entry><link linkend="ext3-journal-data-fl">EXT3_JOURNAL_DATA_FL</link></entry><entry>0x00004000</entry><entry>journal file data</entry></row>
   <row><entry><link linkend="ext2-reserved-fl">EXT2_RESERVED_FL</link></entry><entry>0x80000000</entry><entry>reserved for ext2 implementation</entry></row>
   </tbody>
   </tgroup>
   </table>

   <sect2 id="ext2-secrm-fl"><title>EXT2_SECRM_FL - Secure Deletion</title>
    <para>
	Enabling this bit will cause random data to be written over the file's
	content several times before the blocks are unlinked.  Note that this
	is highly implementation dependant and as such, it should not be assumed
	to be 100% secure.  Make sure to study the implementation notes before
	relying on this option.
    </para>
   </sect2>

   <sect2 id="ext2-unrm-fl"><title>EXT2_UNRM_FL - Record for Undelete</title>
    <para>
	When supported by the implementation, setting this bit will cause the
	deleted data to be moved to a temporary location, where the user can
	restore the original file without any risk of data lost.  This is most
	useful when using ext2 on a desktop or workstation.
    </para>
   </sect2>

   <sect2 id="ext2-compr-fl"><title>EXT2_COMPR_FL - Compressed File</title>
    <para>
	The file's content is compressed.  There is no note about the particular
	algorithm used other than maybe the
	<link linkend="s-algo-bitmap">s_algo_bitmap</link> field of the
	<link linkend="superblock">superblock</link> structure.
    </para>
   </sect2>

   <sect2 id="ext2-sync-fl"><title>EXT2_SYNC_FL - Synchronous Updates</title>
    <para>
	The file's content in memory will be constantly synchronized with the
	content on disk.  This is mostly used for very sensitive boot files
	or encryption keys that you do not want to lose in case of a crash.
    </para>
   </sect2>

   <sect2 id="ext2-immutable-fl"><title>EXT2_IMMUTABLE_FL - Immutable File</title>
    <para>
	The blocks associated with the file will not be exchanged.  If for
	any reason a file system defragmentation is launched, such files will
	not be moved. Mostly used for stage2 and stage1.5 boot loaders.
    </para>
   </sect2>

   <sect2 id="ext2-append-fl"><title>EXT2_APPEND_FL - Append Only</title>
    <para>
	Writing can only be used to append content at the end of the file and
	not modify the current content.  Example of such use could be mailboxes,
	where anybody could send a message to a user but not modify any already
	present.
    </para>
   </sect2>

   <sect2 id="ext2-nodump-fl"><title>EXT2_NODUMP_FL - Do No Dump/Delete</title>
    <para>
	Setting this bit will protect the file from deletion.  As long as this
	bit is set, even if the <link linkend="i-links-count">i_links_count</link>
	is 0, the file will not be removed.
    </para>
   </sect2>

   <sect2 id="ext2-noatime-fl"><title>EXT2_NOATIME_FL - Do Not Update .i_atime</title>
    <para>
	The <link linkend="i-atime">i_atime</link> field of the
	<link linkend="inode-structure">inode</link> structure will not be modified when the
	file is accessed if this bit is set.  The only good use I can think of
	that are related to security.
    </para>
   </sect2>

   <sect2 id="ext2-dirty-fl"><title>EXT2_DIRTY_FL - Dirty</title>
    <para>
 	I do not have information at this moment about the use of this bit.
    </para>
   </sect2>

   <sect2 id="ext2-comprblk-fl"><title>EXT2_COMPRBLK_FL - Compressed Blocks</title>
    <para>
	This flag is set if one or more blocks are compressed.  You can have
	more information about compression on ext2 at
	http://www.netspace.net.au/~reiter/e2compr/  Note that the project has
	not been updated since 1999.
    </para>
   </sect2>

   <sect2 id="ext2-nocompr-fl"><title>EXT2_NOCOMPR_FL - Access Raw Compressed Data</title>
    <para>
	When this flag is set, the file system implementation will not uncompress
	the data before fowarding it to the application but will rather give it as
	is.
    </para>
   </sect2>

   <sect2 id="ext2-ecompr-fl"><title>EXT2_ECOMPR_FL - Compression Error</title>
    <para>
	This flag is set if an error was detected when trying to uncompress the
	file.
    </para>
   </sect2>

   <sect2 id="ext2-btree-fl"><title>EXT2_BTREE_FL - B-Tree Format Directory</title>
    <para>
	
    </para>
   </sect2>

   <sect2 id="ext2-index-fl"><title>EXT2_INDEX_FL - Hash Indexed Directory</title>
    <para>
	When this bit is set, the format of the directory file is hash indexed.
	This is covered in details in <xref linkend="indexed-directory" />.
    </para>
   </sect2>

   <sect2 id="ext2-imagic-fl"><title>EXT2_IMAGIC_FL - </title>
    <para>
    </para>
   </sect2>

   <sect2 id="ext3-journal-data-fl"><title>EXT2_JOURNAL_DATA_FL - Journal File Data</title>
    <para>
    </para>
   </sect2>

   <sect2 id="ext2-reserved-fl"><title>EXT2_RESERVED_FL - Reserved</title>
    <para>
    </para>
   </sect2>
  </sect1>
 </chapter>

 <appendix><title>Credits</title>
  <para>
	I would like to personally thank everybody who contributed to this document,
	you are numerous and in many cases I haven't kept track of all of you.  Be
	sure that if you are not in this list, it's a mistake and do not hesitate
	to contact me, it will be a pleasure to add your name to the list.
  </para>
  <programlisting>
Peter Rottengatter (Peter.Rottengatter@bakerhughes.com)
  Corrections to <xref linkend="s-inodes-per-group" />
  Corrections to <xref linkend="disk-layout-sample-floppy" /> and <xref linkend="disk-layout-sample-20mb" />
  Corrections to <xref linkend="block-group-descriptor-table" />

Ryan Cuthbertson (ryan.cuthbertson@adelaide.edu.au)
  Corrections to <xref linkend="i-blocks" />
  Corrections to <xref linkend="disk-organisation" />

Andreas Gruenbacher (a.gruenbacher@bestbits.at)
  <xref linkend="contrib-extended-attributes" />

Daniel Phillips (phillips@innominate.de)
  <xref linkend="contrib-lookup-algorithm" />
  <xref linkend="contrib-insert-algorithm" />
  <xref linkend="contrib-splitting" />
  <xref linkend="contrib-key-collisions" />
  <xref linkend="contrib-hash-function" />
  <xref linkend="contrib-performance" />

Jeremy Stanley of Access Data Inc.
  Pointed out the inversed values for EXT2_S_IFSOCK and EXT2_S_IFLNK

Ahmed S. Darwish (darwish.07@gmail.com)
  Clarification on <xref linkend="inode-bitmap" />

Sami Besalel (sami.besalel@software.dell.com)
  Typography correction in <xref linkend="ext2-secrm-fl" />.

Kwan Fong (kwanlapfong@gmail.com)
  Improvement to wording in <xref linkend="s-log-block-size" />

Jonatan Schroeder (jonatan@cs.ubc.ca)
  Corrections to <xref linkend="i-block" /> with sparse files.

  </programlisting>
 </appendix>
</book>
